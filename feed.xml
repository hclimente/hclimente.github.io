<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://hclimente.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://hclimente.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-21T00:47:01+00:00</updated><id>https://hclimente.github.io/feed.xml</id><title type="html">blank</title><subtitle>Data Scientist. Machine learning + Genetics. </subtitle><entry><title type="html">Controlling FDR with knockoffs</title><link href="https://hclimente.github.io/blog/kernel-knockoffs/" rel="alternate" type="text/html" title="Controlling FDR with knockoffs"/><published>2025-02-18T12:00:00+00:00</published><updated>2025-02-18T12:00:00+00:00</updated><id>https://hclimente.github.io/blog/kernel-knockoffs</id><content type="html" xml:base="https://hclimente.github.io/blog/kernel-knockoffs/"><![CDATA[<p>In many scientific applications, the goal is to discover which features are truly associated with an outcome. The <a href="https://en.wikipedia.org/wiki/False_discovery_rate">false discovery rate</a> (FDR) is defined as the expected proportion of false positives among the selected features. Controlling the FDR is less conservative than controlling the <a href="https://en.wikipedia.org/wiki/Family-wise_error_rate">family-wise error rate</a>, often leading to more discoveries.</p> <p>When dealing with statistical tests, Benjamini–Hochberg and Benjamini–Yekutieli are common procedures to keep the FDR below a level \(\alpha\). However, such strategies rely on certain assumptions; for instance, that P-values are well-calibrated or that tests have certain correlation structures. If these are not met, the statistical guarantees on FDR control are also out the window. Furthermore, they require having P-values to work with; in many cases we just want to control the FDR of selected features, but do not have a well-characterized null hypothesis. For instance, given a set of active features in Lasso, how can we make sure the fraction of non-explanatory features is controlled? In such cases, <em>knockoffs</em> can be helpful.</p> <h1 id="knockoffs">Knockoffs</h1> <p>The <strong>knockoff</strong> filter is a procedure to perform feature selection while keeping the FDR controlled. Given an outcome \(\mathbf{Y}\) and a feature matrix \(X\), the goal is to select a subset of features \(X_S\) such that</p> \[Y \perp X_{-S} \mid X_S\] <p>The procedure computes and leverages a new matrix \(\tilde{X}\), with the same dimensions as \(X\), containing “knockoff” copies of the original features. Each original variable \(\mathbf{X_i}\) has its own knockoff \(\mathbf{\tilde{X}_i}\). These knockoffs are engineered to mimic the correlation structure of the original features: for any \(i \neq j\), \(\rho(\mathbf{X_i}, \mathbf{X_j}) = \rho(\mathbf{X_i}, \mathbf{\tilde{X}_j}) = \rho(\mathbf{\tilde{X}_i}, \mathbf{\tilde{X}_j})\). Also, knockoffs are created without using \(\mathbf{Y}\). Hence, conditional on \(X\), \(Y\) is independent of \(\tilde{X}\) conditioned on \(X\).</p> <p>There are two paradigms to model knockoffs: Model-X and Fixed-X.</p> <p>The <strong>Model-X</strong> paradigm assumes that the explanatory variables are random variables with a known joint distribution. Although theoretically appealing, this assumption can be impractical for real-world data, since we do not know the data generating function \(F_X\). For that reason, I will ignore it for the remainder of this discussion.</p> <p>The <strong>Fixed-X</strong> paradigm makes no assumptions on the distribution of the explanatory variables. Instead, they can be treated as fixed quantities. This makes it more applicable in practice. However, it imposes three important restrictions:</p> <ul> <li> <table> <tbody> <tr> <td>$$F_{Y</td> <td>X}$$ must be linear and homoscedastic</td> </tr> </tbody> </table> </li> <li>The problem must be low dimensional (number of samples \(&gt;\) number of features)</li> <li>The statistics \(D(X_i, Y)\) and \(D(\tilde{X}_i, Y)\) must satisfy additional requirements (see references)</li> </ul> <h1 id="the-knockoff-procedure">The knockoff procedure</h1> <p>Intuitively, by comparing the association measure computed for each original feature against its knockoff, one can determine which features provide true signals. Specifically, the knockoff-based feature selection consists of the following steps:</p> <ol> <li><a href="#generate-knockoffs">Generate knockoffs</a></li> <li><a href="#compute-association-measures">Compute association measures</a></li> <li><a href="#compute-the-knockoff-statistic">Compute the knockoff statistic</a></li> <li><a href="#select-a-threshold">Select a threshold</a></li> </ol> <h2 id="generate-knockoffs">Generate knockoffs</h2> <p>Create synthetic copies of the features that retain the original correlation structure without any outcome information. An obvious question is how to synthesize such knockoff copies.</p> <h2 id="compute-association-measures">Compute association measures</h2> <p>For each feature, calculate the association measure \(D(\mathbf{Y}, \mathbf{X_k})\) and its counterpart \(D(\mathbf{Y}, \tilde{\mathbf{X}_k})\) on the knockoff.</p> <p>Kernel-based measures are powerful tools for detecting complex, non-linear dependencies:</p> <ul> <li><strong>HSIC (Hilbert-Schmidt Independence Criterion):</strong> Computes the covariance between kernel-transformed versions of the feature and the outcome, capturing a broad range of dependency structures.</li> <li><strong>Conditional MMD (cMMD):</strong> Assesses the difference between the conditional distribution of a feature given the outcome and its marginal distribution. This measure is particularly useful when dealing with categorical outcomes.</li> <li><strong>TR Measure:</strong> A linear combination of Kendall’s τ and Spearman’s ρ, designed to effectively capture associations in both continuous and discrete data.</li> </ul> <p>These measures satisfy the sure independence screening property under bounded kernel conditions—meaning that, with high probability, the truly active features are recovered when a proper threshold is used.</p> <blockquote> <p>A potential limitation of kernel knockoffs is its sometimes overly conservative nature. To keep the FDR low, the procedure may end up selecting very few—or even no—features. This suggests that the chosen association measure might not be sufficiently sensitive. One possible remedy is to explore alternative kernel choices or optimize feature screening steps before applying knockoff filtering.</p> </blockquote> <h2 id="compute-the-knockoff-statistic">Compute the knockoff statistic</h2> <p>Define the statistic as \(w_k = D(Y, X_k) - D(Y, \tilde{X}_k)\). A larger \(w_k\) indicates stronger evidence that the original feature is associated with the outcome.</p> <h2 id="select-a-threshold">Select a threshold</h2> <p>Identify the smallest threshold \(t\) such that \(\frac{\#\{w_k \le -t\}}{\#\{w_k \ge t\}} \le \alpha\) where \(\alpha\) is the desired FDR level. Retain all features with \(w_k \ge t\).</p> <h1 id="screening-in-high-dimensions">Screening in High Dimensions</h1> <p>A notable challenge arises when the number of features \(p\) is large compared to the sample size \(n\) (i.e., \(2p&gt;n\)). In such high-dimensional settings, constructing knockoffs directly is infeasible. A common workaround is to:</p> <ul> <li>Pre-screen Features: Use a subset of the data to rank and reduce the feature set.</li> <li>Apply the knockoff filter: With the reduced set of features, generate knockoffs using the remaining samples (ensuring \(m &gt; 2d\), where \(d\) is the number of features after screening).</li> </ul> <p>This two-step approach helps maintain statistical power while ensuring robust FDR control.</p> <h1 id="references">References</h1> <ul> <li><a href="https://web.stanford.edu/group/candes/knockoffs/">Variable Selection with Knockoffs</a></li> <li><a href="https://proceedings.mlr.press/v151/poignard22a.html">B. Poignard, P. J. Naylor, H. Climente-González, M. Yamada, in International Conference on Artificial Intelligence and Statistics (PMLR, 2022), pp. 1935–1974.</a></li> </ul>]]></content><author><name></name></author><category term="fdr"/><category term="knockoffs"/><category term="feature_selection"/><summary type="html"><![CDATA[An overview of knockoffs]]></summary></entry><entry><title type="html">Random walks and Markov chains</title><link href="https://hclimente.github.io/blog/graphs-random-walks/" rel="alternate" type="text/html" title="Random walks and Markov chains"/><published>2025-01-27T11:59:00+00:00</published><updated>2025-01-27T11:59:00+00:00</updated><id>https://hclimente.github.io/blog/graphs-random-walks</id><content type="html" xml:base="https://hclimente.github.io/blog/graphs-random-walks/"><![CDATA[<h1 id="random-walk">Random walk</h1> <p>A <strong>random walk (RW)</strong> is a <a href="https://en.wikipedia.org/wiki/Stochastic_process">stochastic</a>, discrete process. At every time step a walker, located in one of the graph’s vertices, picks one of its neighbors at random and moves to it. Often the transition probability between vertices is represented by the <strong>transition</strong> matrix \(P\), a normalized version of the <a href="/blog/graphs-linear-algebra/#adjacency-matrix">adjacency</a> in which the weights of all outbound edges add up to 1:</p> \[P = D^{-1} A\] <p>Note that \(P\) corresponds to a <a href="#markov-chains">row stochastic matrix</a>. The outcome of a single random walk is a <a href="/blog/graphs-glossary/#walk">walk</a> of length \(t\), where \(t\) is the number of steps. Let’s see how a random walk starting at vertex \(i\) plays out:</p> <ul> <li>At step 0, \(\mathbf{\pi}_0 = (0, 0, \cdots, 1, \cdots, 0)\). That is, \(\pi_0\) is an \(n\)-dimensional row vector that is \(0\) almost everywhere, with a \(1\) at component \(i\).</li> <li>At step 1, \(\mathbf{\pi}_{1} = \mathbf{\pi}_0 P\)</li> <li>At step 2, \(\mathbf{\pi}_{2} = \mathbf{\pi}_1 P = (\mathbf{\pi}_0 P) P = \mathbf{\pi}_0 P^2\)</li> <li>At step 3, \(\mathbf{\pi}_{3} = \mathbf{\pi}_2 P = (\mathbf{\pi}_0 P^2) P = \mathbf{\pi}_0 P^3\)</li> <li>…</li> <li>At step \(t\), \(\mathbf{\pi}_{t} = \mathbf{\pi}_0 P^t\)</li> </ul> <p>\(\pi_t\) is an \(n\)-dimensional row vector \(\mathbf{\pi}_t\) in which \(\pi_{tj}\) represents the probability of the walker starting at vertex \(i\) and being on vertex $j$ at time $t$.</p> <p>We might be interested in what happens if we let the random walk run indefinitely:</p> \[\lim_{t \to \infty} \mathbf{\pi}_{t} = \mathbf{\pi}_0 P^t\] <p>When taking powers of a matrix, it is useful to use its <a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix">eigendecomposition</a>. After computing the eigenvectors (\(\mathbf{u}_1, \cdots, \mathbf{u}_n\)) and the eigenvalues (\(\lambda_1, \cdots, \lambda_n\)) of \(P\), we first expand \(\mathbf{\pi}_0\) in the eigenbasis:</p> \[\mathbf{\pi}_0 = c_1 \mathbf{u}_1 + c_2 \mathbf{u}_2 + \cdots + c_n \mathbf{u}_n\] <p>Then, for an arbitrary step \(t\):</p> \[\begin{multline*} \mathbf{\pi}_{t} = \mathbf{\pi}_0 P^t \\ = (c_1 \mathbf{u}_1 + \cdots + c_n \mathbf{u}_n) P^t \\ = c_1 \mathbf{u}_1 P^t + \cdots + c_n \mathbf{u}_n P^t \\ = c_1 \lambda^t_1 \mathbf{u}_1 + \cdots + c_n \lambda^t_n \mathbf{u}_n \end{multline*}\] <p>The eigenvalues of a stochastic matrix are always less than or equal to 1 in absolute value. When the random walk is <em>ergodic</em> (see below), \(P\) has an eigenvalue of 1 with an eigenvector \(\pi\) such that:</p> \[\pi_i = \frac {d_i} {\sum_j d_j}.\] <details><summary>Proof</summary> <p>The degree row-vector \(\mathbf{d} = ({d_1}, \cdots, d_n )\) is a left eigenvector of \(P\):</p> \[\mathbf{d} P = \mathbf{d} D^{-1} A = \mathbf{1} A = \mathbf{d}\] <p>where \(\mathbf{1}\) represents the row vector of all ones. That is, \(\mathbf{d}\) is an eigenvector with eigenvalue 1 and non-negative entries. In order to transform it into a valid probability distribution, we need to make sure that \(\sum_i \pi_i = 1\):</p> \[\pi = \frac 1 {\sum_i d_i} \mathbf{d}\] </details> <p>This is the stationary distribution of the random walk. It formalizes the intuitive result that high <a href="/blog/graph-properties/#degree">degree</a> vertices are more likely to be visited. If the graph is <a href="/blog/graphs-glossary/#regular">regular</a>, the stationary distribution is uniform. Note that this is a property of the matrix, and not of \(\pi_0\). This implies that the starting vertex is not important in the long run: if the random walk is allowed to run indefinitely, the probability of ending up in each vertex will converge to \(\pi\).</p> <blockquote> <p><strong>Ergodicity and <em>lazy</em> random walks:</strong> A unique stationary distribution does not always exists. A random walk is <em>ergodic</em> if a stationary distribution exists and is the same for any \(\pi_0\). For the random walk to be ergodic, the graph needs to be connected and non <a href="/blog/graphs-glossary/#bipartite">bipartite</a>. If the graph has multiple components, starting in different components will produce different stationary distributions. If the graph is bipartite, at step \(t\) the walker will be on one side or another, depending on the initial vertex and the parity of \(t\). Bipartite graphs have a ergodic <a href="https://people.orie.cornell.edu/dpw/orie6334/Fall2016/lecture11.pdf"><em>lazy</em> random walk</a>, in which the walker has a probability \(\frac 1 2\) of remaining at the current vertex and a probability \(\frac 1 2\) of leaving it.</p> </blockquote> <details><summary>Connection to the Laplacian</summary> <p>The <a href="/blog/graphs-linear-algebra/#normalized-laplacian-matrices">Laplacian</a> and the transition matrices are deeply related:</p> \[L_{rw} = D^{-1}L = D^{-1}(D - A) = I - P\] <p>In fact, their eigenvectors and eigenvalues are connected. If \(\mathbf{u}\) is an eigenvector of \(P\), with eigenvalue \(\lambda\):</p> \[\mathbf{u} L_{rw} = \mathbf{u} (I - P) = \mathbf{u} - \mathbf{u} P = (1 - \lambda) \mathbf{u}\] <p>That is, \(P\) and \(L_{rw}\) have the same eigenvectors, and the eigenvalues are related as \(\lambda_i(L_{rw}) = 1 - \lambda_i(P)\). Since the <a href="/blog/graphs-linear-algebra/#connectivity-of-the-graph">smallest eigenvalue of \(L_{rw}\)</a> is 0, corresponding to the eigenvector \(\mathbf{1}\), \(P\) has an eigenvalue of \(1\) corresponding to that same eigenvector.</p> </details> <p>There are several remarks we can do:</p> <ul> <li>This result holds regardless of what the starting vertex is. In fact, \(\pi_0\) could be a probability distribution over the vertices.</li> <li>The <em>speed</em> at which the distribution converges depends on the eigenvalues of \(P\). Specifically, if \(\lambda_2\) is close to 1, the convergence will be slow.</li> </ul> <h1 id="random-walk-with-restart">Random walk with restart</h1> <p>In the <strong>random walk with restart (RWR)</strong>, the walker can return to its root vertex with a restart probability \(r \in [0, 1]\):</p> \[\mathbf{\pi}_{t+1} = r \mathbf{\pi}_0 + (1 - r) P \mathbf{\pi}_t\] <p>where \(\mathbf{\pi}_0\) represents the probability of starting at each vertex. If \(r = 0\), the walker will never be teleported back to the root, and a RW is equivalent to a RWR. If \(r = 1\), the walker will not be allowed to move out of the root, and \(\mathbf{\pi}_t = \mathbf{\pi}_0\). However, for certain values of $r$, the walker is allowed to explore the root’s neighborhood before teleporting back. If the root is part of a <a href="/blog/graphs-glossary/#module">module</a>, the walk will mostly happen within that module. If the root is very central, the walker will explore many parts of the network.</p> <p>Importantly, the RWR also has a stationary distribution \(\pi\):</p> \[\lim_{t \to \infty} \mathbf{\pi}_{t} = \pi\] <details><summary>Personalized PageRank</summary> <p>TODO</p> </details> <h1 id="markov-chains">Markov chains</h1> <p>A <strong>Markov chain</strong> is a sequence of events in which the probability of each event only depends on the state attained in the previous event. A random walk is a Markov chain: the probability of visiting a vertex depends only on the current vertex’s neighbors and the corresponding transition probabilities. We can describe some of the properties of a Markov chain by describing the underlying graph:</p> <ul> <li><em>Time reversibility</em></li> <li><em>Symmetry</em>: a Markov chain is symmetric when the underlying graph is <a href="/blog/graphs-glossary/#regular">regular</a>.</li> </ul> <p>In the context of Markov chains, the transition matrix \(P\) is known as the <strong>right stochastic matrix</strong>.</p> <details><summary>Types of stochastic matrices</summary> <ul> <li><strong><em>Row/right</em> stochastic matrix</strong>: square matrix with non-negative entries where each row sums to \(1\).</li> <li><strong><em>Column/left</em> stochastic matrix</strong>: square matrix with non-negative entries where each column sums to \(1\).</li> <li><strong><em>Doubly</em> stochastic matrix</strong>: square matrix with non-negative entries where each row and column sum to \(1\).</li> </ul> </details> <h1 id="further-reading">Further reading</h1> <ul> <li><a href="https://www.youtube.com/watch?v=8XJes6XFjxM">Full title: The Unreasonable Effectiveness of Spectral Graph Theory: A Confluence of Algorithms, Geometry, and Physics</a></li> </ul>]]></content><author><name></name></author><category term="graphs"/><category term="random_walks"/><category term="linear_algebra"/><summary type="html"><![CDATA[PageRank, MCMC, and others]]></summary></entry><entry><title type="html">Graphs and Linear Algebra</title><link href="https://hclimente.github.io/blog/graphs-linear-algebra/" rel="alternate" type="text/html" title="Graphs and Linear Algebra"/><published>2025-01-25T11:59:00+00:00</published><updated>2025-01-25T11:59:00+00:00</updated><id>https://hclimente.github.io/blog/graphs-linear-algebra</id><content type="html" xml:base="https://hclimente.github.io/blog/graphs-linear-algebra/"><![CDATA[<p>In this article I discuss matrices associated to graphs. As we will see, a graph can be represented as a matrix without any information loss. Hence, the properties of these matrices describe <a href="/blog/graphs-basics/#properties-of-a-graph">properties of the underlying graph</a>.</p> <h1 id="matrices-associated-to-graphs">Matrices associated to graphs</h1> <p>A graph \(G = (V, E)\) s.t. \(V = \{v_1, \dots, v_n\}\) and \(E = \{e_1, \dots, e_m \}\) has several important associated matrices. For convenience, I often refer to vertex \(v_i\) simply by its index (\(i\)), and to an edge by the vertices it links (e.g., \(ij\)).</p> <p>I will show examples on the following graph, named \(G_1\):</p> <pre><code class="language-mermaid">---
config:
  layout: elk
  look: handDrawn
---
graph LR
    vertex_1((1))
    vertex_2((2))
    vertex_3((3))
    vertex_4((4))

    vertex_1 === vertex_2
    vertex_1 === vertex_3
    vertex_1 === vertex_4
    vertex_2 === vertex_3
</code></pre> <h2 id="degree-matrix">Degree matrix</h2> <p><a href="/blog/graphs-basics/#degree">Vertex degree</a> is ised to define the <strong>degree</strong> matrix \(D\) is a diagonal \(n \times n\) matrix such that \(D_{ii} = \deg i\), and 0 elsewhere. For instance, for \(G_1\):</p> \[\text{D}(G_1) = \begin{bmatrix} 3 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 2 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 2 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{bmatrix}\] <h2 id="incidence-matrix">Incidence matrix</h2> <p><a href="/blog/graphs-glossary/#incidence">Incidence</a> is used to define the <strong>incidence</strong> matrix \(Q\), a \(n \times m\) matrix such that \(Q_{ij}\) equals:</p> <ul> <li>If \(G\) is <em>directed</em>: <ul> <li>\(0\) if vertex \(i\) and edge \(e_j\) are not incident</li> <li>\(1\) if edge \(e_j\) originates at vertex \(i\)</li> <li>\(-1\) if edge \(e_j\) terminates at vertex \(i\)</li> </ul> </li> <li>If \(G\) is <em>undirected</em>: <ul> <li>If \(Q\) is <em>unoriented</em>: <ul> <li>\(0\) if vertex \(i\) and edge \(e_j\) are not incident</li> <li>\(1\) otherwise</li> </ul> </li> <li>If \(Q\) is <em>oriented</em>: we pick an <a href="/blog/graphs-glossary/#orientation">orientation</a> of the graph, and use the incidence matrix of the resulting directed graph.</li> </ul> </li> </ul> <h2 id="adjacency-matrix">Adjacency matrix</h2> <p><a href="/blog/graphs-glossary/#adjacency">Adjacency</a> is used to define the <strong>adjacency</strong> matrix \(A\), a matrix \(n \times n\) such that the \(A_{ij}\) equals:</p> <ul> <li>\(0\) if vertices \(i\) and \(j\) are not adjacent (note that in simple graphs vertices are not self-adjacent)</li> <li>\(1\) otherwise</li> </ul> <p>For \(G_1\):</p> \[A = \begin{bmatrix} 0 &amp; 1 &amp; 1 &amp; 1 \\ 1 &amp; 0 &amp; 1 &amp; 0 \\ 1 &amp; 1 &amp; 0 &amp; 0 \\ 1 &amp; 0 &amp; 0 &amp; 0 \\ \end{bmatrix}\] <p>The adjacency matrix relates to the concept of <a href="/blog/graphs-glossary/#path">paths</a> in an unweighted graph: \((A^k)_{ij}\) represents the number of paths of length \(k\) from vertex \(i\) to vertex \(j\). In a weighted graph, it represents the sum of products of weights. For instance, if edge weights represent transition probabilities, \((A^k)_{ij}\) represents the probability of starting a <a href="/blog/graphs-random-walks/">walk</a> at node \(i\) and ending at node \(j\) after \(k\) steps.</p> <h2 id="laplacian-matrix">Laplacian matrix</h2> <p>The <strong>Laplacian</strong> matrix \(L\) is a \(n \times n\) matrix such that the \(L_{ij}\) equals::</p> <ul> <li>For \(i \neq j\): <ul> <li>\(0\) if vertices \(i\) and \(j\) are not adjacent</li> <li>\(-1\) otherwise</li> </ul> </li> <li>For \(i = j\), the degree of \(i\).</li> </ul> <p>More concisely, \(L = D - A\). Or, given any oriented incidence matrix \(Q(G)\), \(L = QQ^T\).</p> <p>For \(G_1\):</p> \[L = D - A = \begin{bmatrix} 3 &amp; -1 &amp; -1 &amp; -1 \\ -1 &amp; 2 &amp; -1 &amp; 0 \\ -1 &amp; -1 &amp; 2 &amp; 0 \\ -1 &amp; 0 &amp; 0 &amp; 1 \\ \end{bmatrix}\] <p>The Laplacian relates to the connectedness of a graph, giving rise to <a href="#spectral-graph-theory">spectral graph theory</a>. It also is connected to <a href="/blog/graphs-glossary/#flow">flows</a>. The diagonal entries represent the total outflow capacity from a vertex, while off-diagonal entries encode pairwise connection strengths.</p> <h2 id="normalized-laplacian-matrices">Normalized Laplacian matrices</h2> <p>The presence of <a href="/blog/graphs-glossary/#hub">hubs</a> results in large diagonal entries in the Laplacian. There are normalized versions of the Laplacian that downweigh such vertices by dividing the entries by the vertex degree.</p> <p>The <strong>symmetrically</strong> normalized Laplacian \(L_\text{sym}\) is a symmetric matrix derived as follows:</p> \[L_\text{sym} = D^{-1/2}LD^{-1/2}\] <p>The <strong>random walk</strong> normalized Laplacian \(L_\text{rw}\) is a matrix closely related to <a href="/blog/graphs-random-walks/">random walks</a> that is derived as follows:</p> \[L_\text{rw} = D^{-1}L\] <h1 id="spectral-graph-theory">Spectral graph theory</h1> <p><strong>Spectral graph theory</strong> studies how the eigenvalues and eigenvectors of a graph’s associated matrices relate to its properties. Looking more closely at two of the matrices described above, we can see they have interesting properties:</p> <ul> <li>If \(G\) is undirected, \(A\) is both real and symmetric. Hence, it is diagonalizable and has only <em>real</em> values.</li> <li>Since for an undirected graph both \(D\) and \(A\) are symmetric, \(L\) is also real and symmetric. In fact, \(L\) is <strong>positive semi-definite</strong>. This implies that \(L\)’s eigenvalues are not only real, but also <em>non-negative</em>.</li> </ul> <p>Spectral graph theory often focuses on studying the eigenvalues of the Laplacian.</p> <h2 id="connectivity-of-the-graph">Connectivity of the graph</h2> <p>The eigenvectors of \(L\) are closely related to the connectivity of its associated graph.</p> <p>A simple, but ultimately insightful property of \(L\) is that, for an undirected graph, the sum over the rows or the columns equals 0. In other words, multiplying \(L\) by an all-ones vector \(\mathbf{1}\) results in the zero vector. This tells us that \(L\) has an eigenvalue of 0, corresponding to the eigenvector \(\mathbf{1}\). Separately, linear algebra tells us that since \(L\) is real and symmetric, it has <em>real</em> eigenvalues and <em>orthogonal</em> eigenvectors. And since \(L\) is positive semi-definite, its eigenvalues are <em>non-negative</em>. As we have just seen, the <a href="/blog/graphs-glossary/#first-k-eigenvectors">first eigenvalue</a>, \(\lambda_1\), of \(L\) is 0, corresponding to the \(\mathbf{1}\) eigenvector. If a vector has multiple <a href="/blog/graphs-glossary/#component">components</a>, \(L\) is block diagonal. This makes it easy to see that the indicator vectors, representing the membership of each vertex to one of the components, are eigenvectors with an eigenvalue of 0. This highlights another important property of the Laplacian: given an undirected graph, the multiplicity of the eigenvalue 0 of \(L\) equals the number of <a href="/blog/graphs-glossary/#component">components</a>. Conversely, for a <a href="/blog/graphs-glossary/#connected-graph">connected</a> graph, \(\lambda_2 &gt; 0\). (The second smallest eigenvalue is sometimes called the Fiedler eigenvalue.)</p> <p>More generally, less <em>smooth</em> eigenvectors (i.e., those in which consecutive elements change sharply) indicate a less connected. Equivalently, smaller eigenvalues correspond to smoother eigenvectors, and hence to better connected graphs.</p> <h2 id="spectral-clustering">Spectral clustering</h2> <p>The goal of <strong>spectral clustering</strong> is finding a partition of the graph into \(k\) groups such that the are densely/strongly connected with each other, and sparsely/weakly connected to the others. (If we consider <a href="/blog/graphs-random-walks/">random walks</a>, spectral clustering seeks a partition of the graph such that a random walker tends to stay within each partition, rarely shifting between disjoint sets.) An spectral clustering algorithm, in which seek to find <em>k</em> clusters, looks as follows:</p> <pre><code class="language-pseudocode">\begin{algorithm}
\caption{Spectral Clustering}
\begin{algorithmic}[1]
\PROCEDURE{GraphSpectralClustering}{$$A, k$$}
    \STATE $$n \gets \text{number of nodes (rows in A)}$$

    \STATE Compute degree matrix $$D$$ where $$D[i,i] = \sum_{j=1}^n A[i,j]$$
    \STATE $$D_{\text{sqrt-inv}} \gets \text{diag}(1/\sqrt{D[i,i]})$$
    \STATE $$L_{\text{sym}} \gets I - D_{\text{sqrt-inv}} A D_{\text{sqrt-inv}}$$ \COMMENT{Symmetric normalized Laplacian}

    \STATE Compute first $$k$$ eigenvectors $$u_1, \ldots, u_k$$ of $$L_{\text{sym}}$$
    \STATE Form matrix $$U \in \mathbb{R}^{n \times k}$$ with columns $$u_1, \ldots, u_k$$

    \FOR{$$i = 1$$ \TO $$n$$}
        \STATE $$U[i] \gets U[i] / \|U[i]\|$$ \COMMENT{Row normalization}
    \ENDFOR

    \STATE $$\text{labels} \gets \text{KMeans}(U, k)$$ \COMMENT{Cluster embedded nodes}
    \RETURN $$\text{labels}$$
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</code></pre> <blockquote> <p><strong>Note:</strong> spectral clustering is often applied as a clustering technique on datasets. The aim is to divide the observation into \(k\) groups based on their pairwise similarities. In that case, the first step consists on obtaining the graph. It will be a complete weighted graph in which the vertices are the different observations and the edges are weighted according to the similarity between each pair of vertices, as measured by an arbitrary function.</p> </blockquote> <h2 id="graph-partitioning">Graph partitioning</h2> <p>TODO</p> <h1 id="graph-fourier-transform">Graph Fourier Transform</h1> <p>TODO</p> <h1 id="further-reading">Further reading</h1> <ul> <li><a href="https://people.csail.mit.edu/dsontag/courses/ml14/notes/Luxburg07_tutorial_spectral_clustering.pdf">A Tutorial on Spectral Clustering</a></li> <li><a href="https://mathweb.ucsd.edu/~fan/talks/mlg.pdf">Four graph partitioning algorithms</a></li> <li><a href="https://www.youtube.com/watch?v=uTUVhsxdGS8">Spectral Graph Theory For Dummies</a></li> <li><a href="https://www.youtube.com/watch?v=8XJes6XFjxM">Full title: The Unreasonable Effectiveness of Spectral Graph Theory: A Confluence of Algorithms, Geometry, and Physics</a></li> </ul>]]></content><author><name></name></author><category term="graphs"/><category term="linear_algebra"/><summary type="html"><![CDATA[Matrices associated to graphs and their properties]]></summary></entry><entry><title type="html">Properties of Graphs</title><link href="https://hclimente.github.io/blog/graph-properties/" rel="alternate" type="text/html" title="Properties of Graphs"/><published>2025-01-24T11:59:00+00:00</published><updated>2025-01-24T11:59:00+00:00</updated><id>https://hclimente.github.io/blog/graph-properties</id><content type="html" xml:base="https://hclimente.github.io/blog/graph-properties/"><![CDATA[<p>At the most fundamental level, graphs are just entities and connections between them. Yet, the network topology gives rise to emergent properties. For instance, how information flows through a social network is partly a function who posts the message and how they are connected to the rest of the network, with their immediate connections being likely more important. In this section, I review three levels at which networks operate: <a href="#local-properties">local</a>, <a href="#mesoscale-properties">mesoscale</a> and <a href="#global-properties">global</a>. They refer, respectively, to properties of the nodes, properties of parts of the network and properties of the whole network.</p> <h1 id="local-properties">Local properties</h1> <h2 id="degree">Degree</h2> <p>In an undirected network, the <strong>degree</strong> of a vertex \(u\) (\(\deg u\)) refers to the number of edges that are incident on \(u\). In a directed network, this concept is split between <em>indegree</em> ([\(\deg^- u\)], the number of edges that have \(u\) as their destination) and <em>outdegree</em> ([\(\deg^+ u\)], number of edges that have \(u\) as their source). Weighted graphs extend this concept to <em>weighted</em> degree, in which \(\deg u = \sum_{i} w(e_{ui})\).</p> <h2 id="local-clustering-coefficient">Local clustering coefficient</h2> <p>The <strong>(local) clustering coefficient</strong> <em>of a vertex</em> measures the probability that its <a href="/blog/graphs-glossary/#neighborhood">neighbors</a> are connected. It is computed as the ratio between number of <a href="/blog/graphs-glossary/#triangle-graph">triangles</a> involving a vertex, and the number of <a href="/blog/graphs-glossary/#triplet">triplets</a> involving that same vertex.</p> <p><a href="https://igraph.org/r/doc/transitivity.html">Often</a>, the clustering coefficient of a directed graph is computed without considering the direction of the edges.</p> <h1 id="mesoscale-properties">Mesoscale properties</h1> <h2 id="modularity">Modularity</h2> <p>The <strong>modularity</strong> measures how well a graph can be divided into <a href="/blog/graphs-glossary/#modules">modules</a>. Given a partition of a graph into \(k\) modules, the modularity \(Q\) is computed as</p> \[Q = \sum_{i=1}^k (e_{ii} - {a_i^2})\] <p>where \(e_{ii} = \frac {\| \{\{u, v\} \mid u \in V_i, v \in V_i, \{u, v\} \in E \} \|} {\|E\|}\),\(a*i = \frac {\| \{\{u, v\} \mid u \in V_i, \{u, v\} \in E \} \|} {\|E\|}\) and \(V_i\) is the set of vertices in module \(i\). \(e*{ii}\) is the fraction of edges within module \(i\) and \(a_i\) is the fraction of edges incident with one vertex in module \(i\). \(Q\) will be large when the fraction of edges within the module is much larger than expected by chance.</p> <h2 id="within-module-degree">Within-module degree</h2> <p>The <strong>within-module degree</strong> of a vertex is the module version of the <a href="#degree">degree</a>. It is often normalized as a z-score; the z-score for node \(i\), mapped to module \(k\):</p> \[Z_i = \frac {\kappa_i - \bar \kappa_k} {\sigma_{\kappa_k}}\] <p>where \(\kappa_i\) is within-module degree (the number of edges between \(i\) and other vertices in module \(k\)); \(\bar \kappa_k\) is the average within-module degree; and \(\sigma_{\kappa_k}\) is the standard deviation of the within module degrees.</p> <h2 id="participation">Participation</h2> <p>The <strong>participation coefficient</strong> of a vertex… TODO It is a mesoscale measure of <a href="#centrality">centrality</a>.</p> <h1 id="global-properties">Global properties</h1> <h2 id="radius-and-diameter">Radius and diameter</h2> <p>The radius and the diameter measure how easy it is to traverse a graph. They both are quantities based on the maximum <a href="/blog/graphs-glossary/#distance">distance</a> between any two vertices found in the graph. Specifically, the <strong>radius</strong> is the minimum maximum distance; the <strong>diameter</strong> is the maximum distance.</p> <h2 id="global-clustering-coefficient">Global clustering coefficient</h2> <p>The <strong>global clustering coefficient</strong> <em>of a graph</em> is the ratio between closed and open <a href="/blog/graphs-glossary/#triplet">triplets</a> in that graph. Or, equivalently:</p> \[C = \frac {3 \times \text{triangles}} {\text{triplets}}\] <p><a href="https://igraph.org/r/doc/transitivity.html">Often</a>, the clustering coefficient of a directed graph is computed without considering the direction of the edges.</p> <h2 id="centrality">Centrality</h2> <p><strong>Centrality</strong> assigns a score or a ranking to every vertex in the graph, which represents its importance in the network according to some metric. <a href="#degree">Degree</a> and <a href="#participation">participation</a> are examples of such metrics, but there are others.</p> <p>WIP</p>]]></content><author><name></name></author><category term="graphs"/><summary type="html"><![CDATA[Multiscale ways to talk about graphs]]></summary></entry><entry><title type="html">Introduction to Graphs</title><link href="https://hclimente.github.io/blog/graphs-basics/" rel="alternate" type="text/html" title="Introduction to Graphs"/><published>2025-01-23T11:59:00+00:00</published><updated>2025-01-23T11:59:00+00:00</updated><id>https://hclimente.github.io/blog/graphs-basics</id><content type="html" xml:base="https://hclimente.github.io/blog/graphs-basics/"><![CDATA[<p>Graph theory was founded in the 18th century, with <a href="https://en.wikipedia.org/wiki/Leonhard_Euler">Euler’s</a> article on the <a href="https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg">Seven Bridges of Königsberg problem</a>. The city of Königsberg had seven bridges, connecting the north and south banks of the river, and two fluvial islands (Kneiphof and Lomse). Back then, Königsberg looked roughly like this:</p> <pre><code class="language-mermaid">---
config:
  layout: elk
  look: handDrawn
---
graph LR
    N[North Bank]
    K[Kneiphof Island]
    L[Lomse Island]
    S[South Bank]

    N === K
    N === K
    N === L
    S === L
    S === K
    S === K
    K === L
</code></pre> <p>The problem was to find a path such that a walker would cross each bridge exactly once. To solve this problem (by proving it had no solution), Euler found two useful abstractions: vertices representing land masses, and edges representing bridges. A key insight of framing the problem like this was that a graph can be represented in many ways (e.g., where to position the vertices), and all of them are equivalent.</p> <p>In the 21st century, we define graphs as sets of objects (vertices) and pairwise relations between them (edges). Graphs are also known as networks; vertices as nodes; and edges as links. Königsberg is a graph with 4 vertices and 6 edges. Importantly, graphs represent similarities between objects. In maths, <strong><a href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence</a></strong> formalize the notion than objects can have a relationship of “sameness”. An equivalence relation is a binary relation that is reflexive, transitive and symmetric. It is noted like \(\sim\). The epitome of equivalence relation is “is equal to”. For instance, \(2 = \frac 4 2 = \frac {2\pi} {\pi}\). “Is greater than” is an example of non-equivalence, since it does not meet the symmetric property (e.g., \(2 &gt; 1\) does not imply that \(1 &gt; 2\)). Since edges in a graph also capture this notion of “sameness” in some sense, they are tighly connected to equivalences: \(u \sim v\) implies that there is a <a href="/blog/graphs-glossary/#path">path</a> between vertices \(u\) and \(v\). Equivalently, \(u\) and \(v\) are in the same <a href="/blog/graphs-glossary/#component">component</a>.</p> <p>Importantly, graphs are mathematical objects. A graph \(G\) can be defined as</p> \[G = (V, E)\] <p>Where \(V\) denotes the set of vertices and \(E\) the set of edges (pairs of vertices).</p> <blockquote> <p><strong><em>Notation note:</em></strong> \(V\) and \(E\) above refer sets, specifically to the vertex and edge set of a specific graph (\(G\)). Note that they are in italics. In contrast, the \(\text{V}\) in \(\text{V}(H)\) and \(\text{V}(I)\) refer to the vertex sets of graphs \(H\) and \(I\) respectively. Note that they are not in italics. I will follow the same convention elsewhere, e.g. when writing about <a href="/blog/graphs-linear-algebra/">graph’s matrices</a>.</p> </blockquote> <p>This notation allows to concisely define multiple types of graph:</p> <ul> <li> <p>Undirected graph: \(E \subseteq \{ \{u, v\} \mid u, v \in V \}\), i.e., the edges do not have directions.</p> <pre><code class="language-mermaid">---
config:
layout: elk
look: handDrawn
---
graph LR

    vertex_a((a))
    vertex_b((b))
    vertex_c((c))

    vertex_a === vertex_b
    vertex_a === vertex_c
    vertex_b === vertex_c
</code></pre> </li> <li> <p>Directed graphs: \(E \subseteq \{ (u, v) \mid u, v \in V \}\), i.e., the edges have directions.</p> <pre><code class="language-mermaid">---
config:
layout: elk
look: handDrawn
---
graph LR

    vertex_a((a))
    vertex_b((b))
    vertex_c((c))

    vertex_a --&gt; vertex_b
    vertex_a --&gt; vertex_c
    vertex_b --&gt; vertex_c
</code></pre> </li> </ul> <p>Sometimes, graphs are defined as triples. An example are <a href="/blog/graphs-glossary/#multigraph"><strong>multigraphs</strong></a>, graphs in which multiple edges between the same pair of vertices are allowed. They are triples \(G = (V, E, \phi)\) in which the incidence function \(\phi\) represents the mapping from edges to pairs of vertices. Königsberg is an example of multigraph, since it has multiple bridges connecting the same landmasses (e.g., the North Bank and the Kneiphof Island). For instance, the Königsberg graph is an undirected multigraph with:</p> \[V = \{N, K, L, S \}\] \[E = \{ e_1, e_2, e_3, e_4, e_5, e_6, e_7 \}\] \[\phi(x) = \begin{cases} \{ N, K \} &amp; \text{if $x = e_1$} \\ \{ N, K \} &amp; \text{if $x = e_2$} \\ \{ N, L \} &amp; \text{if $x = e_3$} \\ \{ S, L \} &amp; \text{if $x = e_4$} \\ \{ S, K \} &amp; \text{if $x = e_5$} \\ \{ S, K \} &amp; \text{if $x = e_6$} \\ \{ K, L \} &amp; \text{if $x = e_7$} \\ \end{cases}\] <p>Another type of graph that requires a triple are <strong>weighted</strong> graphs, in which each edge has a weight. They are triples \(G = (V, E, w)\) in which \(w\) is a function that maps edges to their weights. Note that weighted multigraph would be a quadruple, since it would require both an incidence and a weight functions.</p> <blockquote> <p><strong>Note:</strong> unless specified otherwise, in this series I will focus on <a href="/blog/graphs-glossary/#simple-graph"><em>simple</em></a> graphs, which have at most one edge between any pair of vertices and no loops.</p> </blockquote> <h1 id="further-reading">Further reading</h1> <ul> <li><a href="https://arxiv.org/abs/2308.04512">An introduction to graph theory</a></li> </ul>]]></content><author><name></name></author><category term="graphs"/><summary type="html"><![CDATA[Basic definitions]]></summary></entry><entry><title type="html">Graph Glossary</title><link href="https://hclimente.github.io/blog/graphs-glossary/" rel="alternate" type="text/html" title="Graph Glossary"/><published>2025-01-23T11:59:00+00:00</published><updated>2025-01-23T11:59:00+00:00</updated><id>https://hclimente.github.io/blog/graphs-glossary</id><content type="html" xml:base="https://hclimente.github.io/blog/graphs-glossary/"><![CDATA[<h1 id="parts-of-a-graph">Parts of a graph</h1> <h2 id="component">Component</h2> <p>In an undirected graph, a <a href="#connected-graph">connected</a> <a href="#subgraph">subgraph</a> that is not part of a larger connected subgraph.</p> <h2 id="cycle">Cycle</h2> <p>A <a href="#trail">trail</a> in which only the first and last vertices are equal.</p> <h2 id="flow">Flow</h2> <p>An example of a flow is a heat diffusion process across a graph. In such processes, each vertex starts with a certain amount of heat and, at each time point, exchanges heat with its <a href="#neighborhood">neighbors</a> (gains heat from its hotter neighbors; loses it to its colder neighbors).</p> <h2 id="module">Module</h2> <p>A <a href="#subgraph">subgraph</a> whose vertices are densely connected to each other, and loosely to the rest of the graph.</p> <h2 id="orientation">Orientation</h2> <p>An orientation of an undirected graph is the directed graph resulting of assigning a direction to each of its vertices. A directed graph is oriented if no two vertices form a 2-cycle.</p> <h2 id="path">Path</h2> <p>A <a href="#walk">walk</a> with no repeated <em>vertices</em>.</p> <h2 id="spanning-graph">Spanning graph</h2> <p>A subgraph \(G' = (V', E')\) of \(G = (V, E)\) is spanning if \(V' = V\).</p> <h2 id="subgraph">Subgraph</h2> <p>A graph resulting from subsetting vertices from a larger graph, as well as a subset of the edges connecting them.</p> <h3 id="induced-subgraph">Induced subgraph</h3> <p>A <a href="#subgraph">subgraph</a> containing <em>all</em> the edges connecting the vertices in the original graph.</p> <h2 id="trail">Trail</h2> <p>A <a href="#walk">walk</a> with no repeated <em>edges</em>.</p> <h2 id="triplet">Triplet</h2> <p>A set of 3 vertices and at least 2 edges between them, none of which are redundant or loops. <em>Open</em> triplets have exactly 2 edges; <em>closed</em> triplets have exactly 3.</p> <h2 id="walk">Walk</h2> <p>A walk <em>on a graph</em> is an alternating sequence of vertices and edges, such that every vertex is <a href="#incidence">incident</a> with the previous and the following edge (if any).</p> <h1 id="properties-of-vertices">Properties of vertices</h1> <h2 id="adjacency">Adjacency</h2> <p>A vertex is adjacent with <em>another vertex</em> if they are connected by an edge. \(u \sim v\) denote that \(u\) and \(v\) are adjacent.</p> <h2 id="degree">Degree</h2> <p>The degree of a vertex in a (simple) undirected graph is the number of edges <a href="#incidence">incident</a> with that vertex. In a (simple) directed graph we distinguish the indegree (number of edges with the vertex as their <a href="#destination">destination</a>) and the outdegree (number of edges with the vertex as their <a href="#source">source</a>).</p> <h2 id="destination">Destination</h2> <p>In a directed graph, the destination <em>of an edge</em> is the vertex at the head of the edge.</p> <h2 id="distance">Distance</h2> <p>The distance <em>between two vertices</em> is the shortest <a href="#path">path</a> between them.</p> <h2 id="hub">Hub</h2> <p>A vertex with a high <a href="#degree">degree</a>.</p> <h2 id="neighborhood">Neighborhood</h2> <p>The neighborhood of vertex \(v\) is the <a href="#induced-subgraph">induced subgraph</a> containing all the vertices <a href="#adjacency">adjacent</a> to \(v\).</p> <h2 id="incidence">Incidence</h2> <p>A vertex is incident <em>with an edge</em> if the vertex is one of the two vertices the edge connects.</p> <h2 id="source">Source</h2> <p>In a directed graph, the source <em>of an edge</em> is the vertex at the tail of the edge.</p> <h1 id="types-of-graphs">Types of graphs</h1> <h2 id="acyclical-graph">Acyclical graph</h2> <p>A graph without <a href="#cycle">cycles</a>.</p> <h2 id="complete-graph">Complete graph</h2> <p>A simple, undirected graph in which every pair of vertices are connected by an edge.</p> <h2 id="connected-graph">Connected graph</h2> <p>A graph in which a <a href="#path">path</a> exists between every pair of vertices.</p> <h2 id="digraph">Digraph</h2> <p>A directed graph.</p> <h2 id="multigraph">Multigraph</h2> <p>A graph which can have multiple edges between the same pair of vertices.</p> <h2 id="regular">Regular</h2> <p>A graph in which every vertex has the same degree.</p> <h2 id="simple-graph">Simple graph</h2> <p>A graph with at most one edge between any pair of vertices and no loops.</p> <h3 id="triangle-graph">Triangle graph</h3> <p>A <a href="#triplet">triplet</a> with 3 edges. It consists of <em>three</em> closed triplets, each centered around each of the vertices.</p> <h1 id="spectral-graph-theory">Spectral graph theory</h1> <h2 id="first-k-eigenvectors">First <em>k</em> eigenvectors</h2> <p>Eigenvectors associated with the <em>k</em> smallest eigenvalues.</p>]]></content><author><name></name></author><category term="graphs"/><summary type="html"><![CDATA[Definitions of frequent graph terms]]></summary></entry><entry><title type="html">Python functions</title><link href="https://hclimente.github.io/blog/python-functions/" rel="alternate" type="text/html" title="Python functions"/><published>2024-05-26T15:59:00+00:00</published><updated>2024-05-26T15:59:00+00:00</updated><id>https://hclimente.github.io/blog/python-functions</id><content type="html" xml:base="https://hclimente.github.io/blog/python-functions/"><![CDATA[<p>While reading the book “Effective Python: 90 Specific Ways to Write Better Python” I discovered a few interesting behaviors about Python funcions. I list some of them below.</p> <h1 id="functions-arguments-mutable-vs-immutable">Function’s arguments: mutable vs. immutable</h1> <p>The distiction between mutable and immutable datatypes has implications when they are passed to functions as arguments. When an immutable datatype is passed, Python creates a copy and assigns it to a new variable. Hence, the original variable does not get affected:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sum_five</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">+=</span> <span class="mi">5</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="n">a</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">b</span> <span class="o">=</span> <span class="nf">sum_five</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">a = </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">b = </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = 3
b = 8
</code></pre></div></div> <p>Mutable types, on the other hand, are passed by reference. In other words, the function will operate on the same object that existed outside of the function:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">append_three</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
    <span class="nb">input</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">input</span>

<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">b</span> <span class="o">=</span> <span class="nf">append_three</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">a = </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">b = </span><span class="si">{</span><span class="n">b</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = [1, 2, 3]
b = [1, 2, 3]
</code></pre></div></div> <p>TODO decorators TODO lambda functions</p> <h1 id="arguments">Arguments</h1> <h2 id="avoid-mutable-default-arguments">Avoid mutable default arguments</h2> <p>Sometimes we might define some default value for a function’s arguments. However it is often not a good idea to use mutable datatypes as a default. The default object is only created once, leading to counterintuitive behaviors:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">append_three</span><span class="p">(</span><span class="nb">input</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]):</span>
    <span class="nb">input</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">input</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">append_three</span><span class="p">())</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">append_three</span><span class="p">())</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[3]
[3, 3]
</code></pre></div></div> <h2 id="starred-expressions-and-functions">Starred expressions and functions</h2> <p>TODO</p> <h2 id="force-the-use-of-keyword-arguments">Force the use of keyword arguments</h2> <p>We can force the use of keyword arguments using <code class="language-plaintext highlighter-rouge">*</code>:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">debug_info</span> <span class="o">=</span> <span class="sh">""</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">debug_info</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">Formatting string: </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="se">\n</span><span class="sh">"</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">debug_info</span><span class="si">}{</span><span class="n">x</span><span class="p">.</span><span class="nf">title</span><span class="p">()</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">format</span><span class="p">(</span><span class="sh">"</span><span class="s">hey there</span><span class="sh">"</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Formatting string: hey there
Hey There
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">debug_info</span> <span class="o">=</span> <span class="sh">""</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">debug_info</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="s">Formatting string: </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="se">\n</span><span class="sh">"</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">debug_info</span><span class="si">}{</span><span class="n">x</span><span class="p">.</span><span class="nf">title</span><span class="p">()</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>

<span class="nf">format</span><span class="p">(</span><span class="sh">"</span><span class="s">hey there</span><span class="sh">"</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: format() takes 1 positional argument but 2 were given
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">format</span><span class="p">(</span><span class="sh">"</span><span class="s">hey there</span><span class="sh">"</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Formatting string: hey there
Hey There
</code></pre></div></div> <h1 id="functions-as-first-class-citizens">Functions as first-class citizens</h1> <p>As Python objects, functions are first-class citizens, which unlocks several useful features, like closures and decorators.</p> <h2 id="closures">Closures</h2> <h2 id="decorators">Decorators</h2> <p>A decorator is syntactic sugar to easily create a wrapper around our functions.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">wrapper</span><span class="p">()</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
</code></pre></div></div> <h1 id="references">References</h1> <ul> <li>B. Slatkin, Effective Python: 90 Specific Ways to Write Better Python.</li> </ul>]]></content><author><name></name></author><category term="python"/><category term="coding"/><summary type="html"><![CDATA[Fourth post in the Python series]]></summary></entry><entry><title type="html">Data Structures and Algorithms</title><link href="https://hclimente.github.io/blog/data-structures-algorithms/" rel="alternate" type="text/html" title="Data Structures and Algorithms"/><published>2024-02-24T15:59:00+00:00</published><updated>2024-02-24T15:59:00+00:00</updated><id>https://hclimente.github.io/blog/data-structures-algorithms</id><content type="html" xml:base="https://hclimente.github.io/blog/data-structures-algorithms/"><![CDATA[<h1 id="data-structures">Data structures</h1> <h2 id="graphs">Graphs</h2> <p>Graphs are data structures composed of a set of objects (<em>nodes</em>) and pairwise relationships between them (<em>edges</em>). Notably, edges can have properties, like a direction or a weight.</p> <p>Graphs can be represented as:</p> <ul> <li>Adjacency matrices: matrices in which every row \(i\) contains the edges of node \(i\). Specifically, \(\text{row}_{ij}\) is 1 if nodes \(i\) and \(j\) are connected, and 0 otherwise. They are symmetric for undirected graphs.</li> <li>Adjacency list: list of pairs, each of which represents an edge by describing the two involved node indexes. The node order can be meaningful (in directed graphs) or not (in undirected graphs).</li> <li>Hash map: keys are node ids, values are the set of nodes each is connected to. This is a very convenient representation.</li> </ul> <p>A common type of graph in computer science are grids, in which nodes are laid in a grid, and they are connected to the nodes selected top, bottom, left and right.</p> <h2 id="binary-trees">Binary trees</h2> <p>A tree is a graph in which there is only one path between every pair of nodes. Some concepts related to trees are: root, the (only) node on level 1; parent, the connected node in the level above; child, a connected in the level below; and leaf, a node with no children. Importantly, a tree has only one root. A very useful type of tree are <em>binary</em> trees, in which every node has <em>at most</em> two children.</p> <p>Often trees are represented using classes. Specifically, we would have an object <code class="language-plaintext highlighter-rouge">Node</code> like:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div> <p>We would keep a reference to the root, and build a try by successively creating new nodes and assigning them to <code class="language-plaintext highlighter-rouge">.left</code> or <code class="language-plaintext highlighter-rouge">.right</code>.</p> <h3 id="heaps--priority-queues">Heaps / priority queues</h3> <p>(Min-)Heaps are binary trees in which the value of every parent is lower or equal than any of its children. This gives them their most interesting property: the minimum element is always on top. (Similarly, in max-heaps, the maximum stands at the root.) Because of that, they are also called priority queues. A famous algorithm that can be solved with heaps is <a href="https://leetcode.com/problems/find-median-from-data-stream/">computing the running median of a data stream</a>.</p> <p>In Python, <a href="https://docs.python.org/3/library/heapq.html"><code class="language-plaintext highlighter-rouge">heapq</code></a> provides an implementation of the heap. Any populated list can be transformed in-place into a heap:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">123</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]</span>

<span class="n">heapq</span><span class="p">.</span><span class="nf">heapify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[-5, 2, 5, 3, 123, 6, 8]
</code></pre></div></div> <p>The elements have been reordered to represent a heap: each parent note is indexed by \(k\), and its children by \(2k+1\) and \(2k+2\).</p> <p>Let’s see some common operations:</p> <ul> <li> <p>Push a new element (and sift up):</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[-10, -5, 5, 2, 123, 6, 8, 3]
</code></pre></div> </div> </li> <li> <p>Pop the root (and sift down):</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-10
</code></pre></div> </div> </li> <li> <p>Combine the two operations:</p> <ul> <li>Push, then pop: <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">heapq</span><span class="p">.</span><span class="nf">heappushpop</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="c1"># [-5, 2, 5, 3, 123, 6, 8]
</span></code></pre></div> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-7
</code></pre></div> </div> </li> <li>Pop, then push: <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">heapq</span><span class="p">.</span><span class="nf">heapreplace</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="c1"># [-7, 2, 5, 3, 123, 6, 8]
</span></code></pre></div> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-5
</code></pre></div> </div> </li> </ul> </li> </ul> <p>Let’s examine the time complexity of each operation:</p> <ul> <li>Creation: \(O(n)\)</li> <li>Update: \(O(\log n)\)</li> <li>Min/max retrieval: \(O(1)\)</li> </ul> <p><strong>Note:</strong> Heaps are great to recover the smallest element, but not the k<sup>th</sup> smallest one. <a href="#binary-search-trees">BSTs</a> might me more appropriate for that.</p> <h3 id="binary-search-trees">Binary search trees</h3> <p>Binary serach trees (BSTs) are binary trees in which every node meets two properties:</p> <ul> <li>All descendants on the left are smaller than the parent node.</li> <li>All descendants on the right are larger than the parent node.</li> </ul> <p>They provide a good balance between insertion and search speeds:</p> <ul> <li>Search: done recursively on the tree. When balanced, search is as good as binary search on a sorted array.</li> <li>Insertion: also done recursively, by traversing the tree from the root in order until we find an appropriate place.</li> </ul> <p>The time complexity of both is \(O(\log n)\) when the tree is <strong>balanced</strong>; otherwise it is \(O(n)\). (Balanced trees are those whose height is small compared to the number of nodes. Visually, they look full and all branches look similarly long.) As a caveat, no operation takes constant time on a BST.</p> <h2 id="tries">Tries</h2> <p>Tries (from re<em>trie</em>val) are trees that store strings:</p> <ul> <li>Nodes represent characters, except for the root, represents the string start.</li> <li>Children represent each of the possible characters that can follow the parent.</li> <li>Leaf nodes represent the end of the string.</li> <li>Paths from the root to the leafs represent the different words.</li> </ul> <p>Due to its nature, tries excel at two things:</p> <ol> <li>Saving space when storing words sharing the same prefix, since they only store the prefix once.</li> <li>Searching words, which can be done in \(O(\text{word length})\). Similarly, they make it very fast to search for words with a given prefix.</li> </ol> <p>These two properties make them excellent at handling spell checking and autocomplete functions.</p> <h2 id="union-finds">Union-finds</h2> <p>Union-finds, also known as Disjoint-sets, store a collection of non-overlapping sets. Internally, sets are represented as directed trees, in which every member points towards the root of the tree. The root is just another member, which we call the <strong>representative</strong>. Union-finds provide two methods:</p> <ul> <li><strong>Find:</strong> returns the set an element belongs to. Specifically, it returns its representative.</li> <li><strong>Union:</strong> combines two sets. Specifically, first, it performs two finds. If the representatives differ, it will connect one tree’s root to the root of the other.</li> </ul> <p>Union-finds can be represented as an array, in which every member of the universal set is one element. Members linked to a set take as value the index of another member of the set, often the root. Consequently, members that are the only members of a set take their own value. The same goes for the root. While this eliminates many meaningful pairwise relationship between the elements, it speeds up the two core operations.</p> <p>Every set has a property, the <em>rank</em>, which approximates its depth. Union is performed <em>by rank</em>: the root with the highest rank is picked as the new root. Find performs an additional step, called <em>path compresion</em>, in which every member in the path to the root will be directly bound to the root. This increases the cost of that find operation, but keeps the tree shallow and the paths short, and hence speeds up subsequent find operations.</p> <p>Here is a Python implementation:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UnionFind</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>  <span class="c1"># Path compression
</span>        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">rootX</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">rootY</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rootX</span> <span class="o">!=</span> <span class="n">rootY</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">]:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootX</span>
                <span class="n">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootY</span>
                <span class="n">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span>
</code></pre></div></div> <h2 id="bloom-filters">Bloom filters</h2> <p>Bloom filters are data structures to probabilistically check if an element is a member of a set. It can be used when false positives are acceptable, but false negatives are not. For instance, if we have a massive data set, and we want to quickly discard all the elements that are not part of a specific set.</p> <p>The core structure underlying bloom filters is a bit array, which makes it highly compact in memory. When initialized, all the positions are set to 0. When inserting a given element, we apply multiple hash functions to it, each of which would map the element to a bucket in the array. This would be the element’s “signature”. Then, we would set the value of each of these buckets to 1. To probabilistically verify if an element is in the array, we would compute its signature and examine if all the buckets take a value of 1.</p> <h2 id="linked-lists">Linked lists</h2> <p>A linked list is a DAG in which almost every node has exactly one inbound edge and one outbound edge. The exceptions are the <em>head</em>, a node with no inbound egde, and the <em>tail</em>, a node with no outbound edge. Like arrays, linked lists are ordered. However, they have one key diference: insertions in the middle of an array are expensive (\(O(n)\)), since they require copying all the items of the array, while they are cheap in the linked list (\(O(1)\)), since they only require changing two pointers.</p> <p>This is an implementation of a linked list:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>


<span class="n">a</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="sh">"</span><span class="s">D</span><span class="sh">"</span><span class="p">)</span>

<span class="n">a</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">b</span>
<span class="n">b</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">c</span>
<span class="n">c</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">d</span>
</code></pre></div></div> <h1 id="algorithms">Algorithms</h1> <h2 id="divide-and-conquer-problems">Divide and conquer problems</h2> <p>Divide and conquer algorithms work by breaking down a problem into <em>two or more</em> smaller subproblems of the same type. These subproblems are tackled recursively, until the subproblem is simple enough to have a trivial solution. Then, the solutions are combined in a bottom-up fashion. For examples in <a href="#sorting-problems">sorting</a>, see <a href="#merge-sort">merge sort</a> and <a href="#quick-sort">quick sort</a>.</p> <h2 id="intervals-and-scheduling-problems">Intervals and scheduling problems</h2> <p>The input of interval problems is a list of lists, each of which contains a pair <code class="language-plaintext highlighter-rouge">[start_i, end_i]</code> representing an interval. Typical questions revolve around how much they overlap with each other, or inserting and merging a new element.</p> <p><strong>Note:</strong> There are many corner cases, like no intervals, intervals which end and start at the same time or intervals that englobe other intervals. Make sure to think it through.</p> <p><strong>Note:</strong> If the intervals are not sorted, the first step is <em>almost always</em> <strong>sorting them</strong>, either by start or by end. This usually brings the time complexity to \(O(n \log n)\). In some cases we need to perform two sorts, by start and end separately, before merging them. This produces the sequence of events that are happening.</p> <h2 id="sorting-problems">Sorting problems</h2> <p>Sorting consists on arranging the elements of an input array according to some criteria. There are multiple ways to sort an input, each offerintg different trade-offs:</p> <ul> <li>Memory usage: <em>in-place</em> approaches sort the items in place, without using extra space.</li> <li>Stability: stable algorithms preserve the original relative order when faced with two equal keys.</li> <li>Internal vs external: internal sorts operate exclusively on RAM memory; external sorts do it outside (e.g., disk or tape).</li> <li>Recursive vs non-recursive</li> <li>Comparison-based: comparison-based algorithms work by comparing pairs of items. All the algorithms I cover here fall under this category, but not all (e.g., <a href="https://en.wikipedia.org/wiki/Counting_sort">counting sort</a>).</li> </ul> <p>I implement a couple of those below. Their complexities are as follows:</p> <table> <thead> <tr> <th>Algorithm</th> <th>Time complexity</th> <th>Space complexity</th> </tr> </thead> <tbody> <tr> <td><a href="#selection-sort">Selection</a></td> <td>\(O(n^2)\)</td> <td>\(O(1)\)</td> </tr> <tr> <td><a href="#bubble-sort">Bubble</a></td> <td>\(O(n^2)\)</td> <td>\(O(1)\)</td> </tr> <tr> <td><a href="#merge-sort">Merge</a></td> <td>\(O(n \log n)\)</td> <td>\(O(n)\)</td> </tr> <tr> <td><a href="#quick-sort">Quicksort</a></td> <td>\(O(n \log n)\) (average)</td> <td>\(O(\log n)\)</td> </tr> <tr> <td><a href="#topological-sort">Topological</a></td> <td>\(O(|V| + |E|)\)</td> <td>\(O(|V|)\)</td> </tr> </tbody> </table> <h3 id="selection-sort">Selection sort</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">selection_sort</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
        <span class="n">curr_max</span><span class="p">,</span> <span class="n">curr_max_idx</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">"</span><span class="s">-inf</span><span class="sh">"</span><span class="p">),</span> <span class="bp">None</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">curr_max</span><span class="p">:</span>
                <span class="n">curr_max</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">curr_max_idx</span> <span class="o">=</span> <span class="n">j</span>

        <span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">curr_max_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">curr_max_idx</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">x</span>

<span class="nf">bubble_sort</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></div> <h3 id="bubble-sort">Bubble sort</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bubble_sort</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="nf">bubble_sort</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></div> <h3 id="merge-sort">Merge sort</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>

    <span class="c1"># base case
</span>    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="c1"># recursively sort the two halves
</span>    <span class="n">mid</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">sorted_left</span> <span class="o">=</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="n">mid</span><span class="p">])</span>
    <span class="n">sorted_right</span> <span class="o">=</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">mid</span><span class="p">:])</span>

    <span class="c1"># merge the two sorted halves
</span>    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">sorted_left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">sorted_right</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sorted_left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sorted_right</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">merged</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">sorted_left</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">sorted_right</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># since slicing forgives out of bounds starts
</span>    <span class="c1"># hence, this will work when i &gt;= len(sorted_left)
</span>    <span class="n">merged</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">sorted_left</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
    <span class="n">merged</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">sorted_right</span><span class="p">[</span><span class="n">j</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">merged</span>


<span class="nf">merge_sort</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></div> <h3 id="quick-sort">Quick sort</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>

    <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>

    <span class="n">pivot</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># preferrable to modifying the input with x.pop()
</span>    <span class="n">lower</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">higher</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># populate lower and higher in one loop,
</span>    <span class="c1"># instead of two list comprehensions
</span>    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">:</span>
            <span class="n">lower</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">higher</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

    <span class="k">return</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">higher</span><span class="p">)</span>

<span class="nf">quick_sort</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></div> <h3 id="further-reading">Further reading</h3> <ul> <li><a href="https://medium.com/basecs/sorting-out-the-basics-behind-sorting-algorithms-b0a032873add">Sorting Out The Basics Behind Sorting Algorithms</a></li> </ul> <h2 id="linked-lists-1">Linked lists</h2> <h3 id="traversal">Traversal</h3> <p>Traversing a linked list simply consists on passing through every element. We can do that starting from the head, following the pointer to the next node and so on.</p> <p>For instance, this algorithm stores all the values into an array:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>


<span class="k">def</span> <span class="nf">create_list</span><span class="p">():</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="sh">"</span><span class="s">D</span><span class="sh">"</span><span class="p">)</span>
    <span class="n">a</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">b</span>
    <span class="n">b</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">c</span>
    <span class="n">c</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">d</span>
    <span class="k">return</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">fetch_values</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>

    <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span>
    <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
        <span class="n">values</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">curr</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>

<span class="n">a</span> <span class="o">=</span> <span class="nf">create_list</span><span class="p">()</span>
<span class="nf">fetch_values</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['A', 'B', 'C', 'D']
</code></pre></div></div> <p>Or recursively:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fetch_values</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span> <span class="k">return</span> <span class="n">values</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+</span> <span class="nf">fetch_values</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">)</span>


<span class="nf">fetch_values</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['A', 'B', 'C', 'D']
</code></pre></div></div> <h3 id="search">Search</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_value</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>
    <span class="k">elif</span> <span class="n">node</span><span class="p">.</span><span class="n">val</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>

    <span class="k">return</span> <span class="nf">find_value</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="nb">next</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>


<span class="nf">find_value</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="p">)</span> <span class="c1"># True
</span><span class="nf">find_value</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="p">)</span> <span class="c1"># False
</span></code></pre></div></div> <h3 id="keeping-multiple-pointers">Keeping multiple pointers</h3> <p>Often multiple pointers are needed in order to perform certain operations on the list, like reversing it or deleting an element in the middle.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">reverse_list</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>

    <span class="n">left</span><span class="p">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">head</span>

    <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">curr</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="p">,</span> <span class="n">right</span>

    <span class="k">return</span> <span class="n">left</span>


<span class="nf">fetch_values</span><span class="p">(</span><span class="nf">reverse_list</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['D', 'C', 'B', 'A']
</code></pre></div></div> <h3 id="merge-lists">Merge lists</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="nf">create_list</span><span class="p">()</span>

<span class="n">x</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="sh">"</span><span class="s">X</span><span class="sh">"</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="sh">"</span><span class="s">Y</span><span class="sh">"</span><span class="p">)</span>

<span class="n">x</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">head_1</span><span class="p">,</span> <span class="n">head_2</span><span class="p">):</span>

    <span class="n">tail</span> <span class="o">=</span> <span class="n">head_1</span>
    <span class="n">curr_1</span><span class="p">,</span> <span class="n">curr_2</span> <span class="o">=</span> <span class="n">head_1</span><span class="p">.</span><span class="nb">next</span><span class="p">,</span> <span class="n">head_2</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">curr_1</span> <span class="ow">and</span> <span class="n">curr_2</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">counter</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tail</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">curr_1</span>
            <span class="n">curr_1</span> <span class="o">=</span> <span class="n">curr_1</span><span class="p">.</span><span class="nb">next</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tail</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">curr_2</span>
            <span class="n">curr_2</span> <span class="o">=</span> <span class="n">curr_2</span><span class="p">.</span><span class="nb">next</span>

        <span class="n">tail</span> <span class="o">=</span> <span class="n">tail</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">curr_1</span><span class="p">:</span> <span class="n">tail</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">curr_1</span>
    <span class="k">elif</span> <span class="n">curr_2</span><span class="p">:</span> <span class="n">tail</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">curr_2</span>

    <span class="k">return</span> <span class="n">head_1</span>


<span class="nf">fetch_values</span><span class="p">(</span><span class="nf">merge</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['A', 'X', 'B', 'Y', 'C', 'D']
</code></pre></div></div> <h3 id="fast-and-slow-pointers">Fast and slow pointers</h3> <p>Using two pointers that iterate the list at different speeds can help with multiple problems: finding the middle of a list, detecting cycles, or finding the element at a certain distance from the end. For instance, this is how you would use this technique to find the middle node:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_middle</span><span class="p">(</span><span class="n">head</span><span class="p">):</span>
    <span class="n">fast</span> <span class="o">=</span> <span class="n">slow</span> <span class="o">=</span> <span class="n">head</span>
    <span class="k">while</span> <span class="n">fast</span> <span class="ow">and</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">:</span>
        <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="p">.</span><span class="nb">next</span><span class="p">.</span><span class="nb">next</span>
        <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="p">.</span><span class="nb">next</span>
    <span class="k">return</span> <span class="n">slow</span><span class="p">.</span><span class="n">val</span>


<span class="n">a</span> <span class="o">=</span> <span class="nf">create_list</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">find_middle</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
</code></pre></div></div> <h2 id="search-problems">Search problems</h2> <h3 id="linear-search">Linear search</h3> <p>TODO</p> <h3 id="binary-search">Binary search</h3> <p>TODO</p> <h2 id="tree-problems">Tree problems</h2> <p>TODO</p> <h3 id="tree-traversal">Tree traversal</h3> <p>TODO</p> <h4 id="in-order-traversal">In-order traversal</h4> <p>A very useful algorithm to know is how to iterate a BST in order, from the smallest to the largest value in the tree. It has a very compact recursive implementation:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TreeNode</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">right</span>


<span class="k">def</span> <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">+</span> <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">right</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
</code></pre></div></div> <p>However, a non-recursive implementation might be more easily adaptable to other problems:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>

    <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">root</span> <span class="ow">or</span> <span class="n">stack</span><span class="p">:</span>

        <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span>

        <span class="n">root</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="n">output</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">val</span><span class="p">)</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span>

    <span class="k">return</span> <span class="n">output</span>
</code></pre></div></div> <p>For instance, to finding the k-smallest element:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_k_smallest</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">root</span> <span class="ow">or</span> <span class="n">stack</span><span class="p">:</span>

        <span class="k">while</span> <span class="n">root</span><span class="p">:</span>
            <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">left</span>

        <span class="n">root</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">root</span><span class="p">.</span><span class="n">val</span>

        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">right</span>

    <span class="k">return</span> <span class="bp">None</span>


<span class="c1"># Construct the BST
#       3
#      / \
#     1   4
#      \
#       2
</span><span class="n">root</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">root</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">root</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">root</span><span class="p">.</span><span class="n">left</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="nc">TreeNode</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="nf">find_k_smallest</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2
</code></pre></div></div> <h3 id="search-and-delete">Search and delete</h3> <p>TODO</p> <h3 id="insert">Insert</h3> <p>TODO</p> <h2 id="graph-problems">Graph problems</h2> <h3 id="traversals">Traversals</h3> <p>The bread and butter of graph problems are traversal algorithms. Let’s study them.</p> <h4 id="depth-first-traversal">Depth first traversal</h4> <p>In a depth-first traversal (DFT), given a starting node, we recursively visit each of its neighbors before moving to the next one. In a 2D grid, it would involve picking a direction, and following it until we reach a bound. Then we would pick another direction, and do the same. Essentially, the exploration path looks like a snake.</p> <p>The data structure underlying DFT is a <strong>stack</strong>:</p> <ol> <li>When we visit a node, we push all of its neighbors. Hence, each frame in the stack is a node to visit.</li> <li>We pop from the stack to visit the next node. Then we add its neighbors to the stack and continue.</li> <li>Once we can’t go deeper, pop will retrieve the last, unvisited branching point.</li> <li>Once the stack is empty, our job is done.</li> </ol> <p>Let’s see an explicit implementation of the stack:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span><span class="sh">"</span><span class="s">b</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">c</span><span class="sh">"</span><span class="p">},</span>
    <span class="sh">"</span><span class="s">b</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span><span class="sh">"</span><span class="s">d</span><span class="sh">"</span><span class="p">},</span>
    <span class="sh">"</span><span class="s">c</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span><span class="sh">"</span><span class="s">e</span><span class="sh">"</span><span class="p">},</span>
    <span class="sh">"</span><span class="s">d</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span><span class="sh">"</span><span class="s">f</span><span class="sh">"</span><span class="p">},</span>
    <span class="sh">"</span><span class="s">e</span><span class="sh">"</span><span class="p">:</span> <span class="nf">set</span><span class="p">(),</span>
    <span class="sh">"</span><span class="s">f</span><span class="sh">"</span><span class="p">:</span> <span class="nf">set</span><span class="p">(),</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">depth_first_print</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">seed</span><span class="p">]</span>

    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">curr_node</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
        <span class="n">stack</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">curr_node</span><span class="p">])</span>

<span class="nf">depth_first_print</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a
b
d
f
c
e
</code></pre></div></div> <p>Alternatively, we can use a recursive approach and an implicit stack:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">depth_first_print</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">seed</span><span class="p">]:</span>
        <span class="nf">depth_first_print</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">)</span>

<span class="nf">depth_first_print</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a
c
e
b
d
f
</code></pre></div></div> <p>For a graph with nodes \(V\) and edges \(E\), the time complexity is \(O(\|V\|+\|E\|)\) and the space complexity is \(O(\|V\|)\).</p> <p><strong>Note:</strong> Watch out for <em>cycles</em>. Without explicing handling, we might get stuck in infinite traversals. We can keep track of which nodes we have visited using a set, and exit early as soon as we re-visit one.</p> <p><strong>Note:</strong> Some corner cases are the empty graph, graphs with one or two nodes, graphs with multiple components and graphs with cycles.</p> <h4 id="breadth-first-traversal">Breadth first traversal</h4> <p>In a breadth-first traversal (BFT), given a starting node, we first visit its neighbors, then their neighbors, and so on.</p> <p>In a 2D grid, it doesn’t favour any direction. Instead, it looks like a water ripple.</p> <p>The data structure underlying BFT is a <strong>queue</strong>:</p> <ol> <li>When we visit a node, we push all of its neighbors to the queue. As in DFT, each item is a node to visit.</li> <li>We popleft to get the next node. We push allof its neighbors.</li> <li>As before, once the queue is empty, our job is done.</li> </ol> <p>Let’s see an implementation:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span><span class="sh">"</span><span class="s">b</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">c</span><span class="sh">"</span><span class="p">},</span>
    <span class="sh">"</span><span class="s">b</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span><span class="sh">"</span><span class="s">d</span><span class="sh">"</span><span class="p">},</span>
    <span class="sh">"</span><span class="s">c</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span><span class="sh">"</span><span class="s">e</span><span class="sh">"</span><span class="p">},</span>
    <span class="sh">"</span><span class="s">d</span><span class="sh">"</span><span class="p">:</span> <span class="p">{</span><span class="sh">"</span><span class="s">f</span><span class="sh">"</span><span class="p">},</span>
    <span class="sh">"</span><span class="s">e</span><span class="sh">"</span><span class="p">:</span> <span class="nf">set</span><span class="p">(),</span>
    <span class="sh">"</span><span class="s">f</span><span class="sh">"</span><span class="p">:</span> <span class="nf">set</span><span class="p">(),</span>
<span class="p">}</span>

<span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">def</span> <span class="nf">breadth_first_print</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">seed</span><span class="p">])</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">curr_node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
        <span class="n">queue</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">curr_node</span><span class="p">])</span>

<span class="nf">breadth_first_print</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a
b
c
d
e
f
</code></pre></div></div> <p>For a graph with nodes \(V\) and edges \(E\), the time complexity is \(O(\|V\|+\|E\|)\) and the space complexity is \(O(\|V\|)\).</p> <h3 id="topological-sort">Topological sort</h3> <p>A topological sort (or <em>top sort</em>) is an algorithm whose input is a DAG, and whose output is an array such that every node appears after all the nodes that point at it. (Note that, in the presence of cycles, there is no valid topological sorting.) The algorithm looks like this:</p> <ol> <li>Compute the indegree of every node, store it in a hash map.</li> <li>Identify a node with no inbound edges in our hash map.</li> <li>Add the node to the ordering.</li> <li>Decrement the indegree of its neighbors.</li> <li>Repeat from 2 until there are no nodes without inbound edges left.</li> </ol> <p>Put together, the time complexity of top sort is \(O(\|V\| + \|E\|)\), and the space complexity, \(O(\|V\|)\).</p> <h3 id="union-find">Union find</h3> <p>TODO</p> <h3 id="djikstra">Djikstra</h3> <p>TODO</p> <h3 id="min-spanning-tree">Min spanning tree</h3> <p>TODO</p> <h2 id="binary-tree-problems">Binary tree problems</h2> <h3 id="tree-traversals">Tree traversals</h3> <p>As for graph related problems, problems involving trees often require traversals, either <a href="#depth-first-traversal">depth</a> or <a href="#breadth-first-traversal">breadth</a> first. The same principles and data structures apply. For a tree with \(n\) nodes, the time complexity is \(O(n)\), and the time complexity is \(O(n)\). If the tree is balanced, depth first has a space complexity of \(O(\log n)\).</p> <h3 id="further-resources">Further resources</h3> <ul> <li><a href="https://www.youtube.com/watch?v=tWVWeAqZ0WU">Graph Algorithms for Technical Interviews - Full Course</a></li> </ul> <h2 id="two-pointers">Two pointers</h2> <p>The two pointer approach can be used in problems involving searching, comparing and modifying elements in a sequence. A naive approach would involve two loops, and hence take \(O(n^2)\) time. Instead, in the two pointer approach we have two pointers storing indexes, and, by moving them in a coordinate way, we can reduce the complexity down to \(O(n)\). Generally speaking, the two pointers can either move in the same direction, or in opposite directions.</p> <p><strong>Note:</strong> Some two pointer problems require the sequence to be sorted to move the pointers efficiently. For instance, to find the two elements that produce a sum, having a sorted array is key to know which pointer to increase or decrease.</p> <p><strong>Note:</strong> Sometimes we need to iterate an \(m \times n\) table. While we can use two pointers for that, we can to with a single pointer \(i \in [0, m \times n)\): <code class="language-plaintext highlighter-rouge">row = i // n</code>, <code class="language-plaintext highlighter-rouge">col = i % n</code>.</p> <h4 id="sliding-window-problems">Sliding window problems</h4> <p>Sliding window problems are a type of same direction pointer problems. They are optimization problems involving <strong>contiguous</strong> sequences (substrings, subarrays, etc.), particularly involving cumulative properties. The general approach consists on starting with two pointers, <code class="language-plaintext highlighter-rouge">st</code> and <code class="language-plaintext highlighter-rouge">ed</code> at the beginning of the sequence. We can keep track of the cumulative property and update it as the window expands or contracts. We keep increasing <code class="language-plaintext highlighter-rouge">st</code> until we find a window that meets our constraint. Then, we try to reduce it by increasing <code class="language-plaintext highlighter-rouge">st</code>, until it doesn’t meet it anymore. Then, we go back to increasing <code class="language-plaintext highlighter-rouge">ed</code>, and so on.</p> <h2 id="permutation-problems">Permutation problems</h2> <p>Permutation problems can be tackled by <a href="#recursion">recursion</a>.</p> <h2 id="backtracking-problems">Backtracking problems</h2> <p>Backtracking is a family of algorithms characterized by:</p> <ul> <li>The candidate solutions are built incrementally.</li> <li>The solutions have <strong>constraints</strong>, so not all candidates are valid.</li> </ul> <p>Since solutions are built incrementally, backtracting they can be visualized as a <strong>depth-first search</strong> on a tree. At each node, the algorithm checks if it will lead to a valid solution. If the answer is negative, it will <em>backtrack</em> to the parent node, and continue the process.</p> <p><strong>Note:</strong> Because of the need to backtrack, a recursive implementation of the DFS is often more convenient, since undoing a step simply involves invoking <code class="language-plaintext highlighter-rouge">return</code>. A stack might require a more elaborate implementation.</p> <h3 id="a-recipe-for-backtracking-problems">A recipe for backtracking problems</h3> <p>As we will see in a few examples, the solution to a backtracking problem looks like this:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">candidate</span><span class="p">):</span>

    <span class="k">if</span> <span class="nf">is_solution</span><span class="p">(</span><span class="n">candidate</span><span class="p">):</span>
        <span class="nf">output</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="nf">get_children</span><span class="p">(</span><span class="n">candidate</span><span class="p">):</span>
        <span class="k">if</span> <span class="nf">is_valid</span><span class="p">(</span><span class="n">child</span><span class="p">):</span>
            <span class="nf">place</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="nf">solve</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="nf">remove</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
</code></pre></div></div> <h3 id="examples">Examples</h3> <h4 id="the-eight-queens-puzzle">The eight queens puzzle</h4> <p>A famous application of backtracking is solving the <a href="https://en.wikipedia.org/wiki/Eight_queens_puzzle">eight queens puzzle</a>:</p> <blockquote> <p>The eight queens puzzle is the problem of placing eight chess queens on an 8×8 chessboard so that no two queens threaten each other; thus, a solution requires that no two queens share the same row, column, or diagonal. There are 92 solutions.</p> </blockquote> <p>I present here a solution, which mirrors the recipe presented above:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">board</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">under_attack</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">row_i</span><span class="p">,</span> <span class="n">col_i</span> <span class="ow">in</span> <span class="n">board</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">row_i</span> <span class="o">==</span> <span class="n">row</span> <span class="ow">or</span> <span class="n">col_i</span> <span class="o">==</span> <span class="n">col</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c1"># check the diagonals
</span>        <span class="k">if</span> <span class="nf">abs</span><span class="p">(</span><span class="n">row_i</span> <span class="o">-</span> <span class="n">row</span><span class="p">)</span> <span class="o">==</span> <span class="nf">abs</span><span class="p">(</span><span class="n">col_i</span> <span class="o">-</span> <span class="n">col</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>

    <span class="k">return</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">eight_queens</span><span class="p">(</span><span class="n">row</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">row</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">count</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">8</span><span class="p">):</span>
        <span class="c1"># check the constraints: the explored square
</span>        <span class="c1"># is not under attack
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="nf">under_attack</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
            <span class="n">board</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
            <span class="c1"># explore a (so-far) valid path
</span>            <span class="n">count</span> <span class="o">=</span> <span class="nf">eight_queens</span><span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
            <span class="c1"># backtrack!
</span>            <span class="n">board</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">count</span>

<span class="n">total_solutions</span> <span class="o">=</span> <span class="nf">eight_queens</span><span class="p">()</span>
<span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Total solutions: </span><span class="si">{</span><span class="n">total_solutions</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Total solutions: 92
</code></pre></div></div> <h4 id="solving-a-sudoku">Solving a sudoku</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">from</span> <span class="n">pprint</span> <span class="kn">import</span> <span class="n">pprint</span>

<span class="n">board</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>


<span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>

    <span class="n">block_row</span><span class="p">,</span> <span class="n">block_col</span> <span class="o">=</span> <span class="p">(</span><span class="n">row</span> <span class="o">//</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span> <span class="o">//</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">block_row</span> <span class="o">+</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">3</span><span class="p">][</span><span class="n">block_col</span> <span class="o">+</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="bp">True</span>


<span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>

    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
                <span class="k">if</span> <span class="nf">is_valid</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
                    <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">num</span>
                    <span class="k">if</span> <span class="nf">solve</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
                        <span class="k">return</span> <span class="bp">True</span>
                    <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">return</span> <span class="bp">True</span>

<span class="k">if</span> <span class="nf">solve</span><span class="p">(</span><span class="n">board</span><span class="p">):</span>
    <span class="nf">pprint</span><span class="p">(</span><span class="n">board</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">No solution exists.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[2, 7, 4, 1, 9, 3, 8, 6, 5],
 [6, 5, 8, 2, 7, 4, 3, 1, 9],
 [1, 9, 3, 6, 5, 8, 4, 2, 7],
 [5, 8, 1, 7, 4, 6, 2, 9, 3],
 [7, 4, 6, 9, 3, 2, 1, 5, 8],
 [9, 3, 2, 5, 8, 1, 6, 7, 4],
 [3, 2, 7, 8, 1, 9, 5, 4, 6],
 [4, 6, 5, 3, 2, 7, 9, 8, 1],
 [8, 1, 9, 4, 6, 5, 7, 3, 2]]
</code></pre></div></div> <h4 id="permutations-of-a-list">Permutations of a list</h4> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">permute</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>

    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">size</span><span class="p">:</span> <span class="k">return</span> <span class="p">[[]]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
        <span class="c1"># exclude element i
</span>        <span class="n">rest</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">perms</span> <span class="o">=</span> <span class="p">[[</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nf">permute</span><span class="p">(</span><span class="n">rest</span><span class="p">)]</span>
        <span class="n">res</span><span class="p">.</span><span class="nf">extend</span><span class="p">(</span><span class="n">perms</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">res</span>
</code></pre></div></div> <h2 id="dynamic-programming">Dynamic programming</h2> <p>The hallmark of a dynamic programming problem are <strong>overlapping subproblems</strong>.</p> <p>The key to the problem is identifying the <em>trivially</em> smallest input, the case for which the answer is trivially simple.</p> <p>We have two strategies:</p> <ul> <li>Memoization</li> <li>Tabulation</li> </ul> <p>Draw a strategy!!</p> <h3 id="recursion--memoization">Recursion + memoization</h3> <h4 id="recursion">Recursion</h4> <p>Recursion is a technique in to solve problems which in turn depend on solving smaller subproblems. It permeates many other methods, like <a href="#backtracking-problems">backtracking</a>, <a href="#merge-sort">merge sort</a>, <a href="#quick-sort">quick sort</a>, <a href="#binary-search">binary search</a> or <a href="#tree-traversal">tree traversal</a>.</p> <p>Recursive functions have two parts:</p> <ol> <li>Definition of the <strong>base case(s)</strong>, the case(s) in which solving a problem is trivial, and a solution is provided, stopping the recursion.</li> <li>Divide the problem into smaller subproblems, which are sent off to the recursive function.</li> </ol> <p>The space complexity of recursion will be, at least, the length of the stack which accumulates all the function calls.</p> <p><strong>Note:</strong> CPython’s recursion limit is 1,000. This can limit to the depth of the problems we can tackle.</p> <h4 id="memoization">Memoization</h4> <p>TODO</p> <h4 id="recursion--memoization-recipe">Recursion + memoization recipe</h4> <p>In DP, combining recursion and memoization is a powerful way to trade space complexity for time complexity. Specifically, since problems are overlapping, it is likely we are solving the same subproblems over and over, which can get expensive due to recursion. Caching them can greatly improve the speed of our algorithm.</p> <p>Here is a recipe for solving these problems (from <a href="https://www.youtube.com/watch?v=oBt53YbR9Kk">here</a>):</p> <ol> <li>Visualize the problem as a tree</li> <li>Implement the tree using recursion, in which the leaves are the base cases. This will produce the brute force solution.</li> <li>Test it for a few simple cases.</li> <li>Memoize it! <ol> <li>Add a memo dictionary, which keeps getting passed in the recursive calls</li> <li>Add the base cases to the dictionary</li> <li>Store the return values into the memo</li> <li>Return the right value from memo</li> </ol> </li> </ol> <h4 id="computational-complexity">Computational complexity</h4> <p>The computational complexity will be impacted by two factors:</p> <ul> <li><code class="language-plaintext highlighter-rouge">m</code>: the average length of the elements of the input. For instance, if the input is a list, <code class="language-plaintext highlighter-rouge">m = len(input)</code>; it it is an integer, it is <code class="language-plaintext highlighter-rouge">m = input</code>. This will impact the height of the tree.</li> <li><code class="language-plaintext highlighter-rouge">n</code>: the length of the input. This will impact the branching factor. For instance, if the input is a list, <code class="language-plaintext highlighter-rouge">n = len(input)</code>.</li> </ul> <p><strong>Brute force:</strong> for every node, we have a <code class="language-plaintext highlighter-rouge">n</code> options. Usually, the time complexity of DP problems will be exponential, of \(O(n^m*k)\), where $k$ is the complexity of a single recursive call. The memory complexity is the call stack, \(O(m)\).</p> <p><strong>Memoized:</strong> memoization reduces the branching factor by storing previous results. In other words, it trades time complexity for space complexity; usually both become polynomial.</p> <h3 id="tabulation">Tabulation</h3> <p>TODO</p> <h4 id="tabulation-recipe">Tabulation recipe</h4> <p>Taken from <a href="https://www.youtube.com/watch?v=oBt53YbR9Kk">here</a>:</p> <ol> <li>Visualize the problem as a table. Specifically: <ol> <li>Design the size of the table based on the inputs. Often the size of the table is one unit longer in each dimension than the respective inputs. That allows us to include the trivial case (usually in the first position), and nicely aligns our input with the last index.</li> <li>Pick the default value, usually based on what the output value should be.</li> <li>Infuse the trivial answer into the table, the case for which we immediately know the answer</li> </ol> </li> <li>Iterate through the table, filling the positions ahead based on the current position.</li> <li>Retrieve the answer from the relevant position.</li> </ol> <p>Some caveats:</p> <ol> <li>Note that sometimes the trivial case might not have the solution we need to solve the algorithm. Watch out for such situations.</li> </ol> <h3 id="additional-resources">Additional resources</h3> <p>These are some materials that helped me understand dynamic programming (the order matters!):</p> <ol> <li><a href="https://avikdas.com/2019/04/15/a-graphical-introduction-to-dynamic-programming.html">A graphical introduction to dynamic programming</a></li> <li><a href="https://www.youtube.com/watch?v=oBt53YbR9Kk">Dynamic Programming - Learn to Solve Algorithmic Problems &amp; Coding Challenges</a></li> <li><a href="https://qsantos.fr/2024/01/04/dynamic-programming-is-not-black-magic/">Dynamic Programming is not Black Magic</a></li> <li><a href="https://leetcode.com/discuss/study-guide/662866/DP-for-Beginners-Problems-or-Patterns-or-Sample-Solutions">LeetCode: DP for Beginners</a></li> </ol> <h3 id="solved-problems">Solved problems</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">how_sum</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">memo</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{})</span> <span class="o">-&gt;</span> <span class="bp">None</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">.</span><span class="nf">keys</span><span class="p">():</span> <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="nf">how_sum</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">num</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">solution</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">solution</span> <span class="o">+</span> <span class="p">[</span><span class="n">num</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
    <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">return</span> <span class="bp">None</span>

<span class="nf">how_sum</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">])</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">best_sum</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">memo</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{})</span> <span class="o">-&gt;</span> <span class="bp">None</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>

    <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span> <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="bp">None</span>

    <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">length_best_solution</span> <span class="o">=</span> <span class="nf">float</span><span class="p">(</span><span class="sh">"</span><span class="s">inf</span><span class="sh">"</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="nf">best_sum</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">num</span><span class="p">,</span> <span class="n">nums</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">solution</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nf">len</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">length_best_solution</span><span class="p">:</span>
            <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">solution</span> <span class="o">+</span> <span class="p">[</span><span class="n">num</span><span class="p">]</span>
            <span class="n">length_best_solution</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">best_sum</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">best_sum</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">best_sum</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">25</span><span class="p">]))</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">can_construct</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">memo</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{})</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>

    <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span> <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">target</span><span class="p">:</span> <span class="k">return</span> <span class="bp">True</span>

    <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">target</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
            <span class="n">new_target</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="nf">removeprefix</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="k">if</span> <span class="nf">can_construct</span><span class="p">(</span><span class="n">new_target</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
                <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>

    <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">can_construct</span><span class="p">(</span><span class="sh">"</span><span class="s">abcdef</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">ab</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">abc</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">cd</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">def</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">abcd</span><span class="sh">"</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">can_construct</span><span class="p">(</span><span class="sh">"</span><span class="s">skateboard</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">bo</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">rd</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">t</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ska</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">sk</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">boar</span><span class="sh">"</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">can_construct</span><span class="p">(</span><span class="sh">"</span><span class="s">eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">e</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eeee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eeeee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eeeee</span><span class="sh">"</span><span class="p">]))</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">count_construct</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">memo</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{})</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

    <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span> <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">target</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span>

    <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">target</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
            <span class="n">new_target</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="nf">removeprefix</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">+=</span> <span class="nf">count_construct</span><span class="p">(</span><span class="n">new_target</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">count_construct</span><span class="p">(</span><span class="sh">"</span><span class="s">abcdef</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">ab</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">abc</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">cd</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">def</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">abcd</span><span class="sh">"</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">count_construct</span><span class="p">(</span><span class="sh">"</span><span class="s">purple</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">purp</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">p</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ur</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">le</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">purpl</span><span class="sh">"</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">count_construct</span><span class="p">(</span><span class="sh">"</span><span class="s">skateboard</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">bo</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">rd</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">t</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ska</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">sk</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">boar</span><span class="sh">"</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">count_construct</span><span class="p">(</span><span class="sh">"</span><span class="s">eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">e</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eeee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eeeee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eeeee</span><span class="sh">"</span><span class="p">]))</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">all_construct</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">memo</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{})</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>

    <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span> <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">target</span><span class="p">:</span> <span class="k">return</span> <span class="p">[[]]</span>

    <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">target</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="n">word</span><span class="p">):</span>
            <span class="n">new_target</span> <span class="o">=</span> <span class="n">target</span><span class="p">.</span><span class="nf">removeprefix</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
            <span class="n">constructs</span> <span class="o">=</span> <span class="nf">all_construct</span><span class="p">(</span><span class="n">new_target</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
            <span class="n">constructs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">word</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">constructs</span><span class="p">]</span>
            <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">].</span><span class="nf">extend</span><span class="p">(</span><span class="n">constructs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">all_construct</span><span class="p">(</span><span class="sh">"</span><span class="s">abcdef</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">ab</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">abc</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">cd</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">def</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">abcd</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ef</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">c</span><span class="sh">"</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">all_construct</span><span class="p">(</span><span class="sh">"</span><span class="s">purple</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">purp</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">p</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ur</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">le</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">purpl</span><span class="sh">"</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">all_construct</span><span class="p">(</span><span class="sh">"</span><span class="s">skateboard</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">bo</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">rd</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">t</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ska</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">sk</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">boar</span><span class="sh">"</span><span class="p">]))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">all_construct</span><span class="p">(</span><span class="sh">"</span><span class="s">eeeeeeeeeeeeeeeeeeeeef</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">e</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eeee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eeeee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eeeee</span><span class="sh">"</span><span class="p">]))</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fib_t</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

    <span class="n">table</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">table</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">table</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">table</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">table</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">table</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">fib_t</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">fib_t</span><span class="p">(</span><span class="mi">50</span><span class="p">))</span>

<span class="sb">``</span><span class="err">`</span><span class="n">python</span>
<span class="k">def</span> <span class="nf">grid_traveler</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>

    <span class="n">grid</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">grid_traveler</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">grid_traveler</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">grid_traveler</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">grid_traveler</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="nf">grid_traveler</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">18</span><span class="p">))</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">can_sum_t</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Complexity:
        - Time: O(m*n)
        - Space: O(m)
    </span><span class="sh">"""</span>

    <span class="n">grid</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">num</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">can_sum_t</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="p">,</span><span class="mi">3</span><span class="p">]))</span> <span class="c1"># True
</span><span class="nf">print</span><span class="p">(</span><span class="nf">can_sum_t</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]))</span> <span class="c1"># True
</span><span class="nf">print</span><span class="p">(</span><span class="nf">can_sum_t</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="p">,</span><span class="mi">4</span><span class="p">]))</span> <span class="c1"># False
</span><span class="nf">print</span><span class="p">(</span><span class="nf">can_sum_t</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]))</span> <span class="c1"># True
</span><span class="nf">print</span><span class="p">(</span><span class="nf">can_sum_t</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">]))</span> <span class="c1"># False
</span></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">how_sum_t</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">
    Complexity:
        - Time: O(m*n^2)
        - Space: O(m*n)
    </span><span class="sh">"""</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">num</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">copy</span><span class="p">()</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">num</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>


<span class="nf">print</span><span class="p">(</span><span class="nf">how_sum_t</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="p">,</span><span class="mi">3</span><span class="p">]))</span> <span class="c1"># [2, 2, 3]
</span><span class="nf">print</span><span class="p">(</span><span class="nf">how_sum_t</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span> <span class="c1"># [3, 4]
</span><span class="nf">print</span><span class="p">(</span><span class="nf">how_sum_t</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="p">,</span><span class="mi">4</span><span class="p">]))</span> <span class="c1"># None
</span><span class="nf">print</span><span class="p">(</span><span class="nf">how_sum_t</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]))</span> <span class="c1"># [2, 2, 2, 2]
</span><span class="nf">print</span><span class="p">(</span><span class="nf">how_sum_t</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">]))</span> <span class="c1"># None
</span></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">best_sum_t</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nums</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">memo</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{})</span> <span class="o">-&gt;</span> <span class="bp">None</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sh">"""</span><span class="s">
    Complexity:
        - Time: O(m*n^2)
        - Space: O(m^2)
    </span><span class="sh">"""</span>

    <span class="n">grid</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">target</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">num</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">num</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">num</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">num</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">copy</span><span class="p">()</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">num</span><span class="p">].</span><span class="nf">append</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">best_sum_t</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="p">,</span><span class="mi">3</span><span class="p">]))</span> <span class="c1"># [2, 2, 3]
</span><span class="nf">print</span><span class="p">(</span><span class="nf">best_sum_t</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">]))</span> <span class="c1"># [7]
</span><span class="nf">print</span><span class="p">(</span><span class="nf">best_sum_t</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span> <span class="p">,</span><span class="mi">4</span><span class="p">]))</span> <span class="c1"># None
</span><span class="nf">print</span><span class="p">(</span><span class="nf">best_sum_t</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]))</span> <span class="c1"># [5, 3]
</span><span class="nf">print</span><span class="p">(</span><span class="nf">best_sum_t</span><span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">]))</span> <span class="c1"># None
</span></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">can_construct_t</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">words</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Complexity:
        - Time: O(m^2*n)
        - Space: O(m)
    </span><span class="sh">"""</span>

    <span class="n">grid</span> <span class="o">=</span> <span class="p">[</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="n">prefix</span> <span class="o">=</span> <span class="n">target</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="nf">len</span><span class="p">(</span><span class="n">word</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">target</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">word</span><span class="p">):</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="nf">len</span><span class="p">(</span><span class="n">word</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">target</span><span class="p">)]</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">can_construct_t</span><span class="p">(</span><span class="sh">"</span><span class="s">abcdef</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">ab</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">abc</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">cd</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">def</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">abcd</span><span class="sh">"</span><span class="p">]))</span> <span class="c1"># True
</span><span class="nf">print</span><span class="p">(</span><span class="nf">can_construct_t</span><span class="p">(</span><span class="sh">"</span><span class="s">skateboard</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">bo</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">rd</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">t</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ska</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">sk</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">boar</span><span class="sh">"</span><span class="p">]))</span> <span class="c1"># False
</span><span class="nf">print</span><span class="p">(</span><span class="nf">can_construct_t</span><span class="p">(</span><span class="sh">"</span><span class="s">enterapotentpot</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">p</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ent</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">enter</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ot</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">o</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">t</span><span class="sh">"</span><span class="p">]))</span> <span class="c1"># True
</span><span class="nf">print</span><span class="p">(</span><span class="nf">can_construct_t</span><span class="p">(</span><span class="sh">"</span><span class="s">eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">e</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eeee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eeeee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eeeee</span><span class="sh">"</span><span class="p">]))</span> <span class="c1"># False
</span></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">count_construct_t</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">words</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sh">"""</span><span class="s">
    Complexity:
        - Time: O(m^2*n)
        - Space: O(m)
    </span><span class="sh">"""</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="nf">len</span><span class="p">(</span><span class="n">word</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">prefix</span> <span class="o">=</span> <span class="n">target</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">target</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">word</span><span class="p">):</span>
                <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="nf">len</span><span class="p">(</span><span class="n">word</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">target</span><span class="p">)]</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">count_construct_t</span><span class="p">(</span><span class="sh">"</span><span class="s">abcdef</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">ab</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">abc</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">cd</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">def</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">abcd</span><span class="sh">"</span><span class="p">]))</span> <span class="c1"># 1
</span><span class="nf">print</span><span class="p">(</span><span class="nf">count_construct_t</span><span class="p">(</span><span class="sh">"</span><span class="s">purple</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">purp</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">p</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ur</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">le</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">purpl</span><span class="sh">"</span><span class="p">]))</span> <span class="c1"># 2
</span><span class="nf">print</span><span class="p">(</span><span class="nf">count_construct_t</span><span class="p">(</span><span class="sh">"</span><span class="s">skateboard</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">bo</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">rd</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">t</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ska</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">sk</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">boar</span><span class="sh">"</span><span class="p">]))</span> <span class="c1"># 0
</span><span class="nf">print</span><span class="p">(</span><span class="nf">count_construct_t</span><span class="p">(</span><span class="sh">"</span><span class="s">enterapotentpot</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">p</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ent</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">enter</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ot</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">o</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">t</span><span class="sh">"</span><span class="p">]))</span> <span class="c1"># 4
</span><span class="nf">print</span><span class="p">(</span><span class="nf">count_construct_t</span><span class="p">(</span><span class="sh">"</span><span class="s">eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeef</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">e</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eeee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eeeee</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">eeeee</span><span class="sh">"</span><span class="p">]))</span> <span class="c1"># 0
</span></code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="k">def</span> <span class="nf">all_construct_t</span><span class="p">(</span><span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">words</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
    <span class="sh">"""</span><span class="s">
    Complexity:
        - Time: O(n^m)
        - Memory: O(n^m)
    </span><span class="sh">"""</span>

    <span class="n">grid</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
    <span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[]]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">)):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">:</span>
            <span class="nf">if </span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="nf">len</span><span class="p">(</span><span class="n">word</span><span class="p">))</span> <span class="o">&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">prefix</span> <span class="o">=</span> <span class="n">target</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">target</span><span class="p">.</span><span class="nf">startswith</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">word</span><span class="p">):</span>
                <span class="n">new_constructs</span> <span class="o">=</span> <span class="nf">deepcopy</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">new_constructs</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="nf">len</span><span class="p">(</span><span class="n">word</span><span class="p">)]:</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="nf">len</span><span class="p">(</span><span class="n">word</span><span class="p">)].</span><span class="nf">extend</span><span class="p">(</span><span class="n">new_constructs</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">grid</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="nf">len</span><span class="p">(</span><span class="n">word</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_constructs</span>


    <span class="k">return</span> <span class="n">grid</span><span class="p">[</span><span class="nf">len</span><span class="p">(</span><span class="n">target</span><span class="p">)]</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">all_construct_t</span><span class="p">(</span><span class="sh">"</span><span class="s">abcdef</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">ab</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">abc</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">cd</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">def</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">abcd</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ef</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">c</span><span class="sh">"</span><span class="p">]))</span> <span class="c1"># [['ab', 'cd', 'ef'], ['ab', 'c', 'def'], ['abc', 'def'], ['abcd', 'ef']]
</span><span class="nf">print</span><span class="p">(</span><span class="nf">all_construct_t</span><span class="p">(</span><span class="sh">"</span><span class="s">purple</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">purp</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">p</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ur</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">le</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">purpl</span><span class="sh">"</span><span class="p">]))</span> <span class="c1"># [['purp', 'le'], ['p', 'ur', 'p', 'le']]
</span><span class="nf">print</span><span class="p">(</span><span class="nf">all_construct_t</span><span class="p">(</span><span class="sh">"</span><span class="s">skateboard</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">bo</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">rd</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ate</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">t</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ska</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">sk</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">boar</span><span class="sh">"</span><span class="p">]))</span> <span class="c1"># []
</span><span class="nf">print</span><span class="p">(</span><span class="nf">all_construct_t</span><span class="p">(</span><span class="sh">"</span><span class="s">enterapotentpot</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">p</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ent</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">enter</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">ot</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">o</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">t</span><span class="sh">"</span><span class="p">]))</span> <span class="c1"># # [['enter', 'a', 'p', 'ot', 'ent', 'p', 'ot'], ['enter', 'a', 'p', 'ot', 'ent', 'p', 'o', 't'], ['enter', 'a', 'p', 'o', 't', 'ent', 'p', 'ot'], ['enter', 'a', 'p', 'o', 't', 'ent', 'p', 'o', 't']]
</span></code></pre></div></div> <h1 id="how-to-solve-a-problem">How to solve a problem</h1> <p>Stakeholders will sometimes come to us with problems, and we might need to produce a good algorithmic solution pretty quickly; say 45-60 minutes. This is a template on how to tackle these situations.</p> <h2 id="1-problem-statement">1. Problem statement</h2> <p>If our stakeholder is prepared, they might come with a written down problem statement. They might share it with us ahead of our meeting or right at the start.</p> <ol> <li>Make sure you understand the problem: <ol> <li>Paraphrase the problem back to them.</li> <li>If examples (input-output pairs) are provided, walk through one of them.</li> <li>Otherwise, generate a few examples and infer the expected output.</li> </ol> </li> <li>Ask clarifying questions: <ol> <li>About the input: <ul> <li>What are its data types? Is it sorted? Do we know the range of the integers? (Can they be negative?) A batch of a stream? Et cetera.</li> <li>Expected input size: if they know it, might give an idea of the complexity we should aim for. For inputs of size 1 to 100, \(O(n^2)\) is acceptable; for larger inputs, we should do better.</li> </ul> </li> <li>About the edge cases: empty input, invalid, etc.</li> <li>Ask about the specific runtime our solution will need. That will be very useful to screen out solutions and algorithms.</li> </ol> </li> <li>If possible, draw, or at least visualize the problem.</li> </ol> <h2 id="2-brainstorming">2. Brainstorming</h2> <p>While it can be tempting to implement a solution right away, it is worth spending some time drafting the problem. After all, our stakeholder might have given it some thought already, and could be able to point us in the right direction.</p> <ol> <li>Try to match this problem to the problems you have seen. Regarding data structures: <ul> <li>Hash maps: if we need fast lookups</li> <li>Graphs: if we are working with associated entities</li> <li>Stacks and queues: if the input has a nested quality</li> <li>Heaps: if we need to perform scheduling/orderings based on a priority</li> <li>Trees and tries: if we need efficient lookup and storage of strings</li> <li>Linked lists: if we require fast insertions and deletions, especially when order matters</li> <li>Union-finds: if we’re investigating the if sets are connected or cycles exist in a graph Regarding algorithms, there are some recurring ones:</li> <li>Depth-first search</li> <li>Binary Search</li> <li>Sorting Algorithms</li> </ul> </li> <li>Don’t be shy! Let your stakeholder hear out your thought process. They will surely appreciate knowing whats on your mind, and be able to chip in. Specially, if they do say something, <strong>listen</strong>. They are the subject matter experts after all!</li> <li>Once you seem to have converged to a specific approach, state the main parts of the algorithm and make sure they understand and agree. <ul> <li>We might want to start with a suboptimal solution, as long as we let them know that we know that! Once we have that working, we can identify the main bottlenecks and go back to the drawing board.</li> </ul> </li> </ol> <h2 id="3-implementation">3. Implementation</h2> <p>During the implementation phase, it might help to go from the big picture to the small picture. Start by defining the global flow of the program, calling unimplemented functions with clear names. This will allow you to make sure your proposal make sense before getting entangled in the specifics.</p> <p>In order to allow our stakeholder follow our logic, it is important that they can follow along:</p> <ul> <li>Make sure our stakeholder is ok with us using additional dependencies. They might prefer to keep the algorithm lean!</li> <li>Explain why you are making each decision.</li> <li>If you realize your solution might not work, let them know. You might need to go back to brainstorming.</li> <li>Stick to the language conventions. For instance, in PEP8: <ul> <li>Functions are separated by two lines</li> </ul> </li> <li>Keep your code clean: avoid duplicate code, use helper functions, keep function and variable names understandable.</li> <li>Time is limited, so you might want to cut corners, e.g.: <ul> <li>Comments</li> <li>Function typing</li> <li>Checking off-by-one errors when iterating arrays However, let your stakeholder know!</li> </ul> </li> </ul> <p>Once you have a working solution, revisit it:</p> <ul> <li>Scan the code for mistakes. For instance, when working with arrays, index errors are common.</li> <li>Compute the complexity of your code. This might hint at what could be improved. It might also highlight tradeoffs.</li> <li>Identify redundant work</li> <li>Identify overlapping and repeated computations. The algorithm might be sped up by memoization.</li> </ul> <h2 id="4-testing-and-debugging">4. Testing and debugging</h2> <p>Once our solution is ready, it might be a good idea to give it a go. Simply call your function on a few examples. Consider:</p> <ul> <li>“Normal” inputs</li> <li>Trivial inputs</li> <li>Edge inputs</li> <li>Invalid inputs</li> </ul> <p>If some examples fail, we need to debug our code. Throw in a few print statements, predict what you expect to see, and go for it.</p> <h2 id="5-follow-ups">5. Follow-ups</h2> <p>After successfully presenting a solution, our stakeholder might have some follow-up questions:</p> <ul> <li>About our solution: <ul> <li>Time and space complexity? Usually, we should consider the worst case complexity, but if the amortized case is significantly better you should point it out.</li> <li>Specific questions about the choice of algorithm, data structure, loops, etc.</li> <li>What are possible optimizations? <ul> <li>While abstracting specific aspects into functions is helpful, it might also be less efficient (e.g., if we have to iterate the input multiple times instead of one).</li> <li>Identify repeated computations.</li> </ul> </li> <li>Consider non-technical constraints, such as development time, maintainability, or extensibility.</li> </ul> </li> <li>Identify the best theoretical time complexity. This involves considering what is the minimum number of operations involved. For instance if we need to visit every element, probably \(O(n)\) is optimal.</li> </ul> <p><strong>Note:</strong> some algorithms have some implicit and potentially unexpected behaviors. <code class="language-plaintext highlighter-rouge">Ctrl + F</code> “Note:” in order to find some of them.</p> <h2 id="further-reading-1">Further reading</h2> <ul> <li><a href="https://www.teamblind.com/post/New-Year-Gift---Curated-List-of-Top-75-LeetCode-Questions-to-Save-Your-Time-OaM1orEU">“Blind 75” problem set</a></li> <li><a href="https://leetcode.com/explore/interview/card/cheatsheets/720/resources/4723/">Code templates</a></li> <li><a href="https://www.techinterviewhandbook.org/coding-interview-techniques/">Top techniques to approach and solve coding interview questions</a></li> <li><a href="https://sebinsua.com/algorithmic-bathwater#what-kind-of-problem-do-i-have">What kind of problem do I have?</a></li> </ul>]]></content><author><name></name></author><category term="algorithms"/><category term="data-structures"/><category term="coding"/><summary type="html"><![CDATA[Common Problems and How to Solve Them]]></summary></entry><entry><title type="html">Pandas</title><link href="https://hclimente.github.io/blog/python-pandas/" rel="alternate" type="text/html" title="Pandas"/><published>2024-02-20T11:59:00+00:00</published><updated>2024-02-20T11:59:00+00:00</updated><id>https://hclimente.github.io/blog/python-pandas</id><content type="html" xml:base="https://hclimente.github.io/blog/python-pandas/"><![CDATA[<p><a href="https://pandas.pydata.org/">Pandas</a> is the most common Python library to deal with real world data. It builds on top of <a href="/blog/python-vectors/">NumPy</a> to provide useful structures for data scientists.</p> <h1 id="data-structures-provided-by-pandas">Data structures provided by pandas</h1> <p>Pandas provides several data structures, out of which two are particularly popular: Series and DataFrames.</p> <h2 id="series">Series</h2> <p>A Series is a vector-like structure, that extends <a href="/blog/python-vectors/#the-inner-workings-of-numpy-arrays">NumPy vectors</a>.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pandas</span> <span class="k">as</span> <span class="n">pd</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">Series</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">b</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">c</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">d</span><span class="sh">"</span><span class="p">])</span>
<span class="n">x</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a    0
b    1
c    2
d    3
dtype: int64
</code></pre></div></div> <p>The Series stores the data as a NumPy vectors, inheriting its advantages and disadvantages. But computations on Series come with an extra overhead, since Pandas puts extra effort in handling missing values.</p> <h2 id="dataframes">DataFrames</h2> <p>DataFrames are matrix-like structures, which build on top of Series. They can be created in multiple ways, some of which are:</p> <ul> <li>A dictionary of lists/arrays/series <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="sh">'</span><span class="s">Column1</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="sh">'</span><span class="s">Column2</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="sh">'</span><span class="s">A</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">C</span><span class="sh">'</span><span class="p">]}</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</code></pre></div> </div> </li> <li>A list of dictionaries: <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="p">[{</span><span class="sh">'</span><span class="s">Column1</span><span class="sh">'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="sh">'</span><span class="s">Column2</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">A</span><span class="sh">'</span><span class="p">},</span> <span class="p">{</span><span class="sh">'</span><span class="s">Column1</span><span class="sh">'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="sh">'</span><span class="s">Column2</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">B</span><span class="sh">'</span><span class="p">},</span> <span class="p">{</span><span class="sh">'</span><span class="s">Column1</span><span class="sh">'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="sh">'</span><span class="s">Column2</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">C</span><span class="sh">'</span><span class="p">}]</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</code></pre></div> </div> </li> <li>A CSV, Excel or JSON file</li> <li>An SQL query or table</li> </ul> <p>The DataFrame stores data as multiple Series with a shared index. While the data of a Series lives altogether, the different Series of a DataFrame are scattered in memory. In consequence, adding a new column to a DataFrame is fast: Pandas just needs to add its reference to the registry.</p> <h1 id="indexing">Indexing</h1> <p>As in NumPy vectors, we can access a Series’ elements using their <em>positional</em> indexes. But, furthermore, it has an <em>index</em>, a hash map structure which allows us to access each element in the array using a <em>label</em>:</p> <ul> <li><code class="language-plaintext highlighter-rouge">.iloc[]</code> uses the positional indices, and slicing works as usual: <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span><span class="p">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
</code></pre></div> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c    2
dtype: int64
</code></pre></div> </div> </li> <li><code class="language-plaintext highlighter-rouge">.loc[]</code> uses labels, and slicing includes both beginning and end: <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span><span class="p">.</span><span class="n">loc</span><span class="p">[</span><span class="sh">"</span><span class="s">c</span><span class="sh">"</span><span class="p">:</span><span class="sh">"</span><span class="s">d</span><span class="sh">"</span><span class="p">]</span>
</code></pre></div> </div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c    2
d    3
dtype: int64
</code></pre></div> </div> </li> </ul> <p>DataFrames also have a <code class="language-plaintext highlighter-rouge">.loc[]</code> and an <code class="language-plaintext highlighter-rouge">.iloc[]</code> function, which accepts columns as a second argument.</p> <p>Thanks to their dictionary-like properties, indexes allow to access an element in constant time. However, including non-unique indexes might lead to a worst case \(O(n)\) lookup time.</p> <p>Unless otherwise specified, the index gets initialized to a (lazy) enumeration of the rows/items. We can access the index using <code class="language-plaintext highlighter-rouge">.index()</code>, and revert it to this default behaviour using <code class="language-plaintext highlighter-rouge">.reset_index(drop=True)</code>. Note that indexes are immutable, to ensure data integrity. In other words, adding or deleting entries will not alter the index of the remaining elements, in contrast to the positional index.</p> <h2 id="multiindex">MultiIndex</h2> <p><a href="https://pandas.pydata.org/docs/user_guide/advanced.html">MultiIndex</a> is an index in which is key is a (unique) tuple. We can create them from lists of lists or of tuples, from DataFrames, or from the cross-product of two iterables:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="nc">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>

<span class="n">class_1</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">foo</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">bar</span><span class="sh">"</span><span class="p">]</span>
<span class="n">class_2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="p">.</span><span class="n">MultiIndex</span><span class="p">.</span><span class="nf">from_product</span><span class="p">((</span><span class="n">class_1</span><span class="p">,</span> <span class="n">class_2</span><span class="p">),</span>
                                   <span class="c1"># the name of the levels themselves
</span>                                   <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">first</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">second</span><span class="sh">"</span><span class="p">])</span>
<span class="n">x</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">index</span>

<span class="n">x</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>first  second
foo    1         1
       2         2
bar    1         3
       2         4
dtype: int64
</code></pre></div></div> <p>As shown above, the items within a particular position in the tuple to not need to be unique within that position. This allows to select subgroups using <strong>partial</strong> indexes:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span><span class="p">[</span><span class="sh">"</span><span class="s">foo</span><span class="sh">"</span><span class="p">]</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>second
1    1
2    2
dtype: int64
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>first
foo    1
bar    3
dtype: int64
</code></pre></div></div> <h1 id="views-and-copies">Views and copies</h1> <p><a href="/blog/python-vectors/#views-copies-and-in-place-operations">As NumPy</a>, Pandas distinguishes between <em>viewing</em> an object and <em>copying</em> it.</p> <p>TODO</p> <h1 id="further-reading">Further reading</h1> <ul> <li><a href="https://betterprogramming.pub/pandas-illustrated-the-definitive-visual-guide-to-pandas-c31fa921a43">Pandas Illustrated: The Definitive Visual Guide to Pandas</a></li> </ul>]]></content><author><name></name></author><category term="python"/><category term="coding"/><category term="pandas"/><summary type="html"><![CDATA[Cute bear, ok library]]></summary></entry><entry><title type="html">Quirks of Python</title><link href="https://hclimente.github.io/blog/python-quirks/" rel="alternate" type="text/html" title="Quirks of Python"/><published>2024-02-11T15:59:00+00:00</published><updated>2024-02-11T15:59:00+00:00</updated><id>https://hclimente.github.io/blog/python-quirks</id><content type="html" xml:base="https://hclimente.github.io/blog/python-quirks/"><![CDATA[<p>In this post, I present some interesting features of Python that were not within the scope of the previous posts.</p> <h1 id="strings">Strings</h1> <h2 id="string-formatting">String formatting</h2> <p>While Python offers multiple ways of formatting strings (i.e., combining predefined text and variables), <a href="https://docs.python.org/3/tutorial/inputoutput.html#formatted-string-literals">F-strings</a> are particularly elegant:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">constants</span> <span class="o">=</span> <span class="p">{</span>
    <span class="sh">"</span><span class="s">pi</span><span class="sh">"</span><span class="p">:</span> <span class="mf">3.14159265358979323846</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">sqrt(2)</span><span class="sh">"</span><span class="p">:</span> <span class="mf">1.41421356237309504880</span><span class="p">,</span>
    <span class="sh">"</span><span class="s">Euler</span><span class="sh">'</span><span class="s">s number</span><span class="sh">"</span><span class="p">:</span> <span class="mf">2.71828182845904523536</span>
<span class="p">}</span>

<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">constants</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s"> = </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pi = 3.141592653589793
sqrt(2) = 1.4142135623730951
Euler's number = 2.718281828459045
</code></pre></div></div> <p>The float variables can be rounded to a given precision:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">constants</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s"> = </span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="p">.</span><span class="mi">3</span><span class="n">f</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pi = 3.142
sqrt(2) = 1.414
Euler's number = 2.718
</code></pre></div></div> <p>Values can also be formatted to occupy a minimum fixed width:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">constants</span><span class="p">.</span><span class="nf">items</span><span class="p">():</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">name</span><span class="si">:</span><span class="mi">10</span><span class="si">}</span><span class="s"> = </span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="p">.</span><span class="mi">3</span><span class="n">f</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pi         = 3.142
sqrt(2)    = 1.414
Euler's number = 2.718
</code></pre></div></div> <p>Note that the string “Euler’s number” exceeds the minimum length of 10, and is hence represented as is.</p> <h2 id="implicit-string-concatenation">Implicit string concatenation</h2> <p>Strings placed next to each other are automatically concatenated:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span> <span class="sh">"</span><span class="s">foo</span><span class="sh">"</span> <span class="sh">"</span><span class="s">bar</span><span class="sh">"</span> <span class="o">==</span> <span class="sh">"</span><span class="s">foo</span><span class="sh">"</span> <span class="o">+</span> <span class="sh">"</span><span class="s">bar</span><span class="sh">"</span>
</code></pre></div></div> <p>This is useful to cleanly produce long strings while respecting a certain maximum line length:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">message</span> <span class="o">=</span> <span class="sh">"</span><span class="s">Hello, </span><span class="sh">"</span> \
          <span class="sh">"</span><span class="s">World!</span><span class="sh">"</span>
<span class="nf">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Hello, World!
</code></pre></div></div> <h1 id="lists">Lists</h1> <h2 id="enumerate-with-an-offset"><code class="language-plaintext highlighter-rouge">enumerate</code> with an offset</h2> <p>The <a href="https://docs.python.org/3/library/functions.html#enumerate"><code class="language-plaintext highlighter-rouge">enumerate</code></a> function creates a lazy generator over an iterable that will return a tuple (index, item). It can take a second parameter, to indicate the first index to start counting from:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="sh">"</span><span class="s">a</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">b</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">c</span><span class="sh">"</span><span class="p">]</span>

<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nf">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10: a
11: b
12: c
</code></pre></div></div> <h2 id="zip-and-itertoolszip_longest"><code class="language-plaintext highlighter-rouge">zip</code> and <code class="language-plaintext highlighter-rouge">itertools.zip_longest</code></h2> <p>The <a href="https://docs.python.org/3/library/functions.html#zip"><code class="language-plaintext highlighter-rouge">zip</code></a> function combines two or more iterators, generating a lazy generator which yields the next item from each. It is particularly useful to handle related lists that have the same length:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">squared</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">numbers</span><span class="p">]</span>

<span class="k">for</span> <span class="n">number</span><span class="p">,</span> <span class="n">square</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">squared</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">The square of </span><span class="si">{</span><span class="n">number</span><span class="si">}</span><span class="s"> is </span><span class="si">{</span><span class="n">square</span><span class="si">}</span><span class="s">.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The square of 1 is 1.
The square of 2 is 4.
The square of 3 is 9.
</code></pre></div></div> <p>However, when the two iterables have different lenghts, <code class="language-plaintext highlighter-rouge">zip</code> will only emit as many elements as the shortest of them:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xs</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ys</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>

<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 0
1 1
2 2
3 3
</code></pre></div></div> <p>When we do not wish this truncation to happen, <a href="https://docs.python.org/3/library/itertools.html#itertools.zip_longest"><code class="language-plaintext highlighter-rouge">itertools.zip_longest</code></a> might be what we need:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">itertools</span> <span class="kn">import</span> <span class="n">zip_longest</span>

<span class="n">xs</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="n">ys</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>

<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nf">zip_longest</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 0
1 1
2 2
3 3
None 4
</code></pre></div></div> <h1 id="sorting-by-complex-criteria">Sorting by complex criteria</h1> <p>The <a href="https://docs.python.org/3/library/stdtypes.html#list.sort"><code class="language-plaintext highlighter-rouge">list.sort</code></a> method orders a list’s elements in ascending order. It will work as long as the items have defined the <code class="language-plaintext highlighter-rouge">&lt;</code> comparison operator, as is the case for floats, integers and strings. However, in some cases that operator might not be implemented, or might not be making the comparison that we care about. The <code class="language-plaintext highlighter-rouge">key</code> argument is helpful in those cases:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Animal</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">self</span><span class="p">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">weight</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="sh">"</span><span class="s">Animal(</span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">self</span><span class="p">.</span><span class="n">weight</span><span class="si">}</span><span class="s">)</span><span class="sh">"</span>

<span class="n">animals</span> <span class="o">=</span> <span class="p">[</span>
    <span class="nc">Animal</span><span class="p">(</span><span class="sh">"</span><span class="s">whale</span><span class="sh">"</span><span class="p">,</span> <span class="mi">100000</span><span class="p">),</span>
    <span class="nc">Animal</span><span class="p">(</span><span class="sh">"</span><span class="s">sea lion</span><span class="sh">"</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span>
    <span class="nc">Animal</span><span class="p">(</span><span class="sh">"</span><span class="s">lion</span><span class="sh">"</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span>
    <span class="nc">Animal</span><span class="p">(</span><span class="sh">"</span><span class="s">possum</span><span class="sh">"</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="p">]</span>

<span class="c1"># sort by weight
</span><span class="n">animals</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">weight</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">animals</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Animal(possum, 2.5), Animal(sea lion, 200), Animal(lion, 200), Animal(whale, 100000)]
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># sort by name
</span><span class="n">animals</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">animals</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Animal(lion, 200), Animal(possum, 2.5), Animal(sea lion, 200), Animal(whale, 100000)]
</code></pre></div></div> <p>As shown, <code class="language-plaintext highlighter-rouge">key</code> takes a function which will receive an item, and output a comparable value. If we want to order first by weight, then by name, we just need to combine both in a tuple:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># sort by name
</span><span class="n">animals</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">name</span><span class="p">))</span>
<span class="nf">print</span><span class="p">(</span><span class="n">animals</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Animal(possum, 2.5), Animal(lion, 200), Animal(sea lion, 200), Animal(whale, 100000)]
</code></pre></div></div> <h1 id="the-walrus-operator">The walrus operator</h1> <p>The <a href="https://docs.python.org/3/reference/expressions.html#assignment-expressions">walrus operator</a> (<code class="language-plaintext highlighter-rouge">:=</code>) allows to assign variables in the middle of expressions:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_divisor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Check if y is a divisor of x.

    Parameters:
    - x (int): The dividend.
    - y (int): The potential divisor.

    Returns:
    tuple: A tuple containing a boolean indicating whether y is a divisor of x,
           and the remainder when x is divided by y. If y is a divisor, the
           boolean is True, and the remainder is 0; otherwise, the boolean is
           False, and the remainder is the result of x % y.
    </span><span class="sh">"""</span>
    <span class="k">if</span> <span class="n">remainder</span> <span class="p">:</span><span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span><span class="p">,</span> <span class="n">remainder</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span><span class="p">,</span> <span class="mi">0</span>

<span class="nf">print</span><span class="p">(</span><span class="nf">is_divisor</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(True, 0)
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="nf">is_divisor</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(False, 1)
</code></pre></div></div> <p>The walrus operator is present in the first line of the <code class="language-plaintext highlighter-rouge">is_divisor</code> function. It allows two things to happen at once. First, the <code class="language-plaintext highlighter-rouge">if</code> clause will evaluate the expression <code class="language-plaintext highlighter-rouge">x % y</code> (false if the remainder is 0; true if it’s any other number). Additionally, it is setting the <code class="language-plaintext highlighter-rouge">remainder</code> variable to <code class="language-plaintext highlighter-rouge">x % y</code>. This makes the code easier to understand, since <code class="language-plaintext highlighter-rouge">remainder</code> is only defined if it is going to be used.</p> <h1 id="floats-and-integers">Floats and integers</h1> <h2 id="underscores-as-visual-separators">Underscores as visual separators</h2> <p>We can use underscores <code class="language-plaintext highlighter-rouge">_</code> as visual separators between any pair of digits in integers, floats or complex numbers:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span> <span class="mi">10_000_000</span> <span class="o">==</span> <span class="mi">10000000</span>
<span class="k">assert</span> <span class="mf">1_100.3</span> <span class="o">==</span> <span class="mf">1100.3</span>
</code></pre></div></div> <p>I find this particularly useful when dealing with large numbers.</p> <h2 id="limitations-of-floating-point-arithmetic">Limitations of floating point arithmetic</h2> <p>Most decimal floating-point numbers cannot be represented as binary floating-point numbers. Instead, computers just store an approximation. This behavior is not evident by just asking Python to display a number, since it will round it:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">print</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0.1
</code></pre></div></div> <p>However, if we request Python to give more significant digits:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">format</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="sh">'</span><span class="s">.20g</span><span class="sh">'</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'0.10000000000000000555'
</code></pre></div></div> <p>While this approximation is smaller than \(2^(-53)\), that is enough to cause errors:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span> <span class="p">.</span><span class="mi">1</span> <span class="o">+</span> <span class="p">.</span><span class="mi">2</span> <span class="o">==</span> <span class="p">.</span><span class="mi">3</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AssertionError
</code></pre></div></div> <p>Luckily, we can get around it with a little extra work:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">math</span>

<span class="k">assert</span> <span class="n">math</span><span class="p">.</span><span class="nf">isclose</span><span class="p">(.</span><span class="mi">1</span> <span class="o">+</span> <span class="p">.</span><span class="mi">2</span><span class="p">,</span> <span class="p">.</span><span class="mi">3</span><span class="p">)</span>

<span class="k">assert</span> <span class="nf">round</span><span class="p">(.</span><span class="mi">1</span> <span class="o">+</span> <span class="p">.</span><span class="mi">2</span><span class="p">,</span> <span class="n">ndigits</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nf">round</span><span class="p">(.</span><span class="mi">3</span><span class="p">,</span> <span class="n">ndigits</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div> <h1 id="generators">Generators</h1> <p>TODO</p> <h1 id="typing-hints">Typing hints</h1> <p>In this series, we have seen multiple examples in which the type of a variable is specified. For instance:</p> <ul> <li>Variables:</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
</code></pre></div></div> <ul> <li>Function arguments and return values:</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pretty_print</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s">: </span><span class="sh">"</span> <span class="k">if</span> <span class="n">prefix</span> <span class="k">else</span> <span class="sh">""</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">x</span><span class="p">.</span><span class="nf">title</span><span class="p">()</span><span class="si">}</span><span class="s">.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>Note that typing hints are a relatively recent addition to Python. Typing hints of recent verions of Python might produce parsing errors on older version.</p> <p>The stdlib’s <a href="https://docs.python.org/3/library/typing.html"><code class="language-plaintext highlighter-rouge">typing</code></a> module gives many options to control type hints. (Widely used packages bring their own typing hints, like <a href="https://numpy.org/devdocs/reference/typing.html">numpy</a>.) Below I explore some interesting features.</p> <h2 id="overloading-functions">Overloading functions</h2> <p>The decorator <code class="language-plaintext highlighter-rouge">@typing.overload</code> allows to overload functions, that is, have a function behave differently depending on the argument type.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">typing</span> <span class="kn">import</span> <span class="n">overload</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="bp">...</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="bp">...</span>

<span class="k">def</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="nf">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="nf">square</span><span class="p">(</span><span class="n">_x</span><span class="p">)</span> <span class="k">for</span> <span class="n">_x</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
</code></pre></div></div> <h2 id="type-checking">Type checking</h2> <p>Python is a dynamically typed language. Hence, typing hints are just, that, hints. However, we can use <a href="https://github.com/python/mypy">mypy</a> on our entire codebase to check that types are used correctly.</p> <h1 id="bitwise-operations">Bitwise operations</h1> <h2 id="for-integer-arithmetic">For integer arithmetic</h2> <p>Some people are really concerned by performance. Their concern is such that they are willing to sacrifice code readability for minor gains in performance. Such people might get satisfaction from replacing arithmetic operations involving integers by bitwise operations. Since those act directly on the bit representation of the integer, they can be more efficient. Despite compilers performing some optimization of their own, <a href="https://stackoverflow.com/questions/37053379/times-two-faster-than-bit-shift-for-python-3-x-integers">there is some somewhat old evidence supporting that bitwise operations are faster.</a> I describe below some common optimizations.</p> <h3 id="dividing-and-multiplying-by-powers-of-two">Dividing and multiplying by powers of two</h3> <p>The <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> and the <code class="language-plaintext highlighter-rouge">&lt;&lt;</code> operators shift the bit representation to the left and to the right, respectively. This can be used to quickly divide or multiply integers by powers of two:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mb">0b101</span> <span class="c1"># 5
</span>
<span class="c1"># shift to the right by 1
#   0b101 &gt;&gt; 0b10
# equivalent to 5 // 2**1
</span><span class="mi">5</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="c1"># 2
</span>
<span class="c1"># shift to the left by 4
#   0b101 &gt;&gt; 0b1010000
# 5 * 2**4
</span><span class="mi">5</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span> <span class="c1"># 80
</span></code></pre></div></div> <h3 id="check-if-a-number-is-odd">Check if a number is odd</h3> <p>The <code class="language-plaintext highlighter-rouge">&amp;</code> operator is the bitwise AND operator. When we use <code class="language-plaintext highlighter-rouge">&amp;</code> between any integer and a 1, we are effectively cheching if the last bit is a 1 (odd) or a 0 (even):</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 0b1110 &amp; 0b0001 = 0b0000 = 0
</span><span class="k">assert</span> <span class="ow">not</span> <span class="mi">14</span> <span class="o">&amp;</span> <span class="mi">1</span>

<span class="c1"># 0b1111 &amp; 0b0001 = 0b0001 = 1
</span><span class="k">assert</span> <span class="mi">15</span> <span class="o">&amp;</span> <span class="mi">1</span>
</code></pre></div></div> <h2 id="iterate-a-list-from-the-end">Iterate a list from the end</h2> <p>The <code class="language-plaintext highlighter-rouge">~</code> operator is the complement operator, which switches 1s by 0s and vice versa. Let’s see it in action:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 0b01 -&gt; 0b10
</span><span class="k">assert</span> <span class="o">~</span><span class="mi">1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span>
<span class="k">assert</span> <span class="o">~-</span><span class="mi">2</span> <span class="o">==</span> <span class="mi">3</span>
</code></pre></div></div> <p>Since the first bit represents the sign, it has the effect of turning \(x\) into \(-x - 1\). This is useful when we need to simultaneously iterate the front and the back of a list:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="nf">all</span><span class="p">([</span><span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">word</span><span class="p">[</span><span class="o">~</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)])</span>

<span class="k">assert</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="sh">"</span><span class="s">kayak</span><span class="sh">"</span><span class="p">)</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="nf">is_palindrome</span><span class="p">(</span><span class="sh">"</span><span class="s">dog</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <h1 id="exceptions">Exceptions</h1> <p>Handling exceptions with <code class="language-plaintext highlighter-rouge">try: ... except: ...</code> is a common in Python code. But there are some additional nuances:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y</span> <span class="o">=</span> <span class="nf">list</span><span class="p">()</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">y</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{}[</span><span class="mi">1</span><span class="p">]</span>
<span class="c1"># we can handle multiple, specific exceptions
</span><span class="k">except</span> <span class="nb">TypeError</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Can</span><span class="sh">'</span><span class="s">t sum an integer and a </span><span class="si">{</span><span class="nf">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s">.</span><span class="sh">"</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">AttributeError</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Can</span><span class="sh">'</span><span class="s">t append to </span><span class="si">{</span><span class="nf">type</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="si">}</span><span class="s">.</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># we can still add a catch-all exception
</span><span class="k">except</span><span class="p">:</span>
    <span class="c1"># we can throw our own exception
</span>    <span class="k">raise</span> <span class="nc">Exception</span><span class="p">(</span><span class="sh">"</span><span class="s">Something went wrong.</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># behavior if no error is raised
</span><span class="k">else</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">All good.</span><span class="sh">"</span><span class="p">)</span>
<span class="c1"># a block that will be run no matter what,
# usually good for clean up
</span><span class="k">finally</span><span class="p">:</span>
    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Thanks anyway.</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <h1 id="context-managers">Context managers</h1> <p>A context manager is a programming construct that makes it easy to allocate and release resources. It is useful to handle file operations, network connections or database transactions, when it is important to release the resource when we are done with it. They can be used using the <code class="language-plaintext highlighter-rouge">with</code> statement. The context manager class needs two methods: <code class="language-plaintext highlighter-rouge">__enter__</code>, to setup the resource, and <code class="language-plaintext highlighter-rouge">__exit__</code>, to clean up and release the resource.</p> <h1 id="references">References</h1> <ul> <li>D. Beazley, <a href="https://github.com/dabeaz-course/python-mastery">Advanced Python Mastery</a></li> <li>B. Slatkin, Effective Python: 90 Specific Ways to Write Better Python.</li> <li><a href="https://peps.python.org/pep-0515/">PEP 515 – Underscores in Numeric Literals</a></li> </ul>]]></content><author><name></name></author><category term="python"/><category term="coding"/><summary type="html"><![CDATA[A catch-all of interesting behaviors]]></summary></entry></feed>