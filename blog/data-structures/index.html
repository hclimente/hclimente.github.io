<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Compendium of Data Structures | Héctor Climente-González </title> <meta name="author" content="Héctor Climente-González"> <meta name="description" content="Representing data the right way"> <meta name="keywords" content="machine-learning, genetics, pharma, drug-discovery, climente, climente-gonzalez"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%AA%A2&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://hclimente.github.io/blog/data-structures/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Héctor</span> Climente-González </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Compendium of Data Structures</h1> <p class="post-meta"> Created on February 24, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/computer-science"> <i class="fa-solid fa-hashtag fa-sm"></i> computer_science</a>   <a href="/blog/tag/data-structures"> <i class="fa-solid fa-hashtag fa-sm"></i> data_structures</a>   <a href="/blog/tag/coding"> <i class="fa-solid fa-hashtag fa-sm"></i> coding</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="graphs">Graphs</h1> <p>Graphs are data structures composed of a set of objects (<em>nodes</em>) and pairwise relationships between them (<em>edges</em>). Notably, edges can have properties, like a direction or a weight.</p> <p>Graphs can be represented as:</p> <ul> <li>Adjacency matrices: matrices in which every row \(i\) contains the edges of node \(i\). Specifically, \(\text{row}_{ij}\) is 1 if nodes \(i\) and \(j\) are connected, and 0 otherwise. They are symmetric for undirected graphs.</li> <li>Adjacency list: list of pairs, each of which represents an edge by describing the two involved node indexes. The node order can be meaningful (in directed graphs) or not (in undirected graphs).</li> <li>Hash map: keys are node ids, values are the set of nodes each is connected to. This is a very convenient representation.</li> </ul> <p>A common type of graph in computer science are grids, in which nodes are laid in a grid, and they are connected to the nodes selected top, bottom, left and right.</p> <h1 id="binary-trees">Binary trees</h1> <p>A tree is a graph in which there is only one path between every pair of nodes. Some concepts related to trees are: root, the (only) node on level 1; parent, the connected node in the level above; child, a connected in the level below; and leaf, a node with no children. Importantly, a tree has only one root. A very useful type of tree are <em>binary</em> trees, in which every node has <em>at most</em> two children.</p> <p>Often trees are represented using classes. Specifically, we would have an object <code class="language-plaintext highlighter-rouge">Node</code> like:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">self</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div> <p>We would keep a reference to the root, and build a try by successively creating new nodes and assigning them to <code class="language-plaintext highlighter-rouge">.left</code> or <code class="language-plaintext highlighter-rouge">.right</code>.</p> <h2 id="heaps--priority-queues">Heaps / priority queues</h2> <p>(Min-)Heaps are binary trees in which the value of every parent is lower or equal than any of its children. This gives them their most interesting property: the minimum element is always on top. (Similarly, in max-heaps, the maximum stands at the root.) Because of that, they are also called priority queues. A famous algorithm that can be solved with heaps is <a href="https://leetcode.com/problems/find-median-from-data-stream/" rel="external nofollow noopener" target="_blank">computing the running median of a data stream</a>.</p> <p>In Python, <a href="https://docs.python.org/3/library/heapq.html" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">heapq</code></a> provides an implementation of the heap. Any populated list can be transformed in-place into a heap:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">heapq</span>

<span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">123</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]</span>

<span class="n">heapq</span><span class="p">.</span><span class="nf">heapify</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[-5, 2, 5, 3, 123, 6, 8]
</code></pre></div></div> <p>The elements have been reordered to represent a heap: each parent note is indexed by \(k\), and its children by \(2k+1\) and \(2k+2\).</p> <p>Let’s see some common operations:</p> <ul> <li> <p>Push a new element (and sift up):</p> <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div> </div> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>[-10, -5, 5, 2, 123, 6, 8, 3]
</code></pre></div> </div> </li> <li> <p>Pop the root (and sift down):</p> <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div> </div> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>-10
</code></pre></div> </div> </li> <li> <p>Combine the two operations:</p> <ul> <li>Push, then pop: <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">heapq</span><span class="p">.</span><span class="nf">heappushpop</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="c1"># [-5, 2, 5, 3, 123, 6, 8]
</span></code></pre></div> </div> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>-7
</code></pre></div> </div> </li> <li>Pop, then push: <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">heapq</span><span class="p">.</span><span class="nf">heapreplace</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">7</span><span class="p">)</span> <span class="c1"># [-7, 2, 5, 3, 123, 6, 8]
</span></code></pre></div> </div> <div class="language-plaintext highlighter-rouge"> <div class="highlight"><pre class="highlight"><code>-5
</code></pre></div> </div> </li> </ul> </li> </ul> <p>Let’s examine the time complexity of each operation:</p> <ul> <li>Creation: \(O(n)\)</li> <li>Update: \(O(\log n)\)</li> <li>Min/max retrieval: \(O(1)\)</li> </ul> <p><strong>Note:</strong> Heaps are great to recover the smallest element, but not the k<sup>th</sup> smallest one. <a href="#binary-search-trees">BSTs</a> might me more appropriate for that.</p> <h2 id="binary-search-trees">Binary search trees</h2> <p>Binary serach trees (BSTs) are binary trees in which every node meets two properties:</p> <ul> <li>All descendants on the left are smaller than the parent node.</li> <li>All descendants on the right are larger than the parent node.</li> </ul> <p>They provide a good balance between insertion and search speeds:</p> <ul> <li>Search: done recursively on the tree. When balanced, search is as good as binary search on a sorted array.</li> <li>Insertion: also done recursively, by traversing the tree from the root in order until we find an appropriate place.</li> </ul> <p>The time complexity of both is \(O(\log n)\) when the tree is <strong>balanced</strong>; otherwise it is \(O(n)\). (Balanced trees are those whose height is small compared to the number of nodes. Visually, they look full and all branches look similarly long.) As a caveat, no operation takes constant time on a BST.</p> <h1 id="tries">Tries</h1> <p>Tries (from re<em>trie</em>val) are trees that store strings:</p> <ul> <li>Nodes represent characters, except for the root, represents the string start.</li> <li>Children represent each of the possible characters that can follow the parent.</li> <li>Leaf nodes represent the end of the string.</li> <li>Paths from the root to the leafs represent the different words.</li> </ul> <p>Due to its nature, tries excel at two things:</p> <ol> <li>Saving space when storing words sharing the same prefix, since they only store the prefix once.</li> <li>Searching words, which can be done in \(O(\text{word length})\). Similarly, they make it very fast to search for words with a given prefix.</li> </ol> <p>These two properties make them excellent at handling spell checking and autocomplete functions.</p> <h1 id="union-finds">Union-finds</h1> <p>Union-finds, also known as Disjoint-sets, store a collection of non-overlapping sets. Internally, sets are represented as directed trees, in which every member points towards the root of the tree. The root is just another member, which we call the <strong>representative</strong>. Union-finds provide two methods:</p> <ul> <li> <strong>Find:</strong> returns the set an element belongs to. Specifically, it returns its representative.</li> <li> <strong>Union:</strong> combines two sets. Specifically, first, it performs two finds. If the representatives differ, it will connect one tree’s root to the root of the other.</li> </ul> <p>Union-finds can be represented as an array, in which every member of the universal set is one element. Members linked to a set take as value the index of another member of the set, often the root. Consequently, members that are the only members of a set take their own value. The same goes for the root. While this eliminates many meaningful pairwise relationship between the elements, it speeds up the two core operations.</p> <p>Every set has a property, the <em>rank</em>, which approximates its depth. Union is performed <em>by rank</em>: the root with the highest rank is picked as the new root. Find performs an additional step, called <em>path compresion</em>, in which every member in the path to the root will be directly bound to the root. This increases the cost of that find operation, but keeps the tree shallow and the paths short, and hence speeds up subsequent find operations.</p> <p>Here is a Python implementation:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UnionFind</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">size</span><span class="p">)]</span>
        <span class="n">self</span><span class="p">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>  <span class="c1"># Path compression
</span>        <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">rootX</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">rootY</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rootX</span> <span class="o">!=</span> <span class="n">rootY</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">]:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootX</span>
                <span class="n">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">self</span><span class="p">.</span><span class="n">parent</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span> <span class="o">=</span> <span class="n">rootY</span>
                <span class="n">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">rootY</span><span class="p">]</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">rank</span><span class="p">[</span><span class="n">rootX</span><span class="p">]</span>
</code></pre></div></div> <h1 id="probabilistic-data-structures">Probabilistic data structures</h1> <h2 id="bloom-filters">Bloom filters</h2> <p>Bloom filters are data structures to probabilistically check if an element is a member of a set. It can be used when false positives are acceptable, but false negatives are not. For instance, if we have a massive data set, and we want to quickly discard all the elements that are not part of a specific set.</p> <p>The core structure underlying bloom filters is a bit array, which makes it highly compact in memory. When initialized, all the positions are set to 0. When inserting a given element, we apply multiple hash functions to it, each of which would map the element to a bucket in the array. This would be the element’s “signature”. Then, we would set the value of each of these buckets to 1. To probabilistically verify if an element is in the array, we would compute its signature and examine if all the buckets take a value of 1.</p> <h2 id="skip-lists">Skip lists</h2> <p><em>See <a href="/blog/rags/#nearest-neighbor-search">how they relate to RAGs</a>.</em></p> <p><strong>Skip lists</strong> are a data structure consisting of a set of <a href="#linked-lists">linked lists</a>, each one containing a subset of the items in the collection:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/2025-08-16-rags/skip_list.drawio-480.webp 480w,/assets/img/posts/2025-08-16-rags/skip_list.drawio-800.webp 800w,/assets/img/posts/2025-08-16-rags/skip_list.drawio-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/posts/2025-08-16-rags/skip_list.drawio.png" class="img-fluid" width="100%" height="auto" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <div class="caption"> Example of search path for a value (9) in a 5-layered skip list. </div> <p>The topmost list contains only a few items, while the bottommost list contains all the items. Each item in a list points to the next item in the same list, and also to the next item in the lists below it. This allows us to quickly traverse the lists and find or insert items in logarithmic time with high probability:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">find_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">query_number</span><span class="p">):</span>

    <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span> <span class="o">&lt;</span> <span class="n">query_number</span><span class="p">:</span>
        <span class="c1"># keep moving right whenever possible
</span>		<span class="k">return</span> <span class="nf">find_entry</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">,</span> <span class="n">query_number</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">node</span><span class="p">.</span><span class="n">down</span><span class="p">:</span>
        <span class="c1"># move down when we can't move right anymore
</span>        <span class="k">return</span> <span class="nf">find_entry</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">down</span><span class="p">,</span> <span class="n">query_number</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
        <span class="c1"># we are at the bottom layer
</span>        <span class="k">if</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span><span class="p">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">query_number</span><span class="p">:</span>
		    <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">right</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># not found
</span>            <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div> <h1 id="linked-lists">Linked lists</h1> <p>A linked list is a DAG in which almost every node has exactly one inbound edge and one outbound edge. The exceptions are the <em>head</em>, a node with no inbound egde, and the <em>tail</em>, a node with no outbound edge. Like arrays, linked lists are ordered. However, they have one key diference: insertions in the middle of an array are expensive (\(O(n)\)), since they require copying all the items of the array, while they are cheap in the linked list (\(O(1)\)), since they only require changing two pointers.</p> <p>This is an implementation of a linked list:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">self</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="bp">None</span>


<span class="n">a</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="sh">"</span><span class="s">A</span><span class="sh">"</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="sh">"</span><span class="s">B</span><span class="sh">"</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="nc">Node</span><span class="p">(</span><span class="sh">"</span><span class="s">D</span><span class="sh">"</span><span class="p">)</span>

<span class="n">a</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">b</span>
<span class="n">b</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">c</span>
<span class="n">c</span><span class="p">.</span><span class="nb">next</span> <span class="o">=</span> <span class="n">d</span>
</code></pre></div></div> </div> </article> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <br> <script defer src="/assets/js/giscus-setup.js"></script> <noscript> Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 Héctor Climente-González. All content and views expressed here are strictly personal and do not reflect the opinions, policies, or practices of my current or former employer. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>