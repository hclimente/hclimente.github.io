<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Vectors and matrices in Python | Héctor Climente-González </title> <meta name="author" content="Héctor Climente-González"> <meta name="description" content="NumPy and vectorization"> <meta name="keywords" content="machine-learning, genetics, pharma, drug-discovery, climente, climente-gonzalez"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%AA%A2&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://hclimente.github.io/blog/python-vectors/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav sticky-bottom-footer"> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Héctor</span> Climente-González </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Vectors and matrices in Python</h1> <p class="post-meta"> Created in February 08, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/python"> <i class="fa-solid fa-hashtag fa-sm"></i> python</a>   <a href="/blog/tag/coding"> <i class="fa-solid fa-hashtag fa-sm"></i> coding</a>   <a href="/blog/tag/numpy"> <i class="fa-solid fa-hashtag fa-sm"></i> numpy</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>In data science we often operate on numerical vectors are matrices. Although we could store such data as Python’s builtins, as a list and a list of lists respectively, we don’t. Instead, we use specialized packages like <a href="https://numpy.org/" rel="external nofollow noopener" target="_blank">NumPy</a>, which provide much better performances. In this post I dig into the reasons behind this superiority. As is common in this series, I assume familiarity with Python, and NumPy in this case.</p> <h1 id="the-inner-workings-of-numpy-arrays">The inner workings of NumPy arrays</h1> <p>The main selling point of NumPy is the speed up in computations it offers. However, to understand that, we need to first understand the underpinnings of the NumPy array, or <code class="language-plaintext highlighter-rouge">ndarray</code>. The <code class="language-plaintext highlighter-rouge">ndarray</code> is made up of two components: an array (the <em>data buffer</em>) containing the data, and the metadata, containing information about the data buffer.</p> <p>The <strong>data buffer</strong> is an array of elements of the same type:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="c1"># ndarrays can contain multiple data types, e.g.,
# integers
</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

<span class="c1"># floats
</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">])</span>

<span class="c1"># 1-character string
</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="sh">"</span><span class="s">1</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">2</span><span class="sh">"</span><span class="p">,</span> <span class="sh">"</span><span class="s">3</span><span class="sh">"</span><span class="p">])</span>

<span class="c1"># Python references - which, as we will see soon,
# greatly undoes the benefits of NumPy
</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span>
</code></pre></div></div> <p>Let’s compare this to a Python builtin: a list containing floats. <a href="../python-lists">Remember</a> that each of the 64-bit buckets does not store the float, but a 64-bit reference to the float object. This keeps lists flexible, since each bucket can contain a reference to any object, float or not. But it comes with a memory overhead since, on top of the reference, we need to store the object itself, <a href="../python-objects/#properties-of-an-object">which is more complex than a naked float value</a>. In contrast, an <code class="language-plaintext highlighter-rouge">ndarray</code> stores only the floats themselves, requiring less than 25% of the memory. Furthermore, in the list of floats, the data is <em>fragmented</em>: the list itself, and all the objects it references are scattered across memory. In contrast, the whole data buffer lives in a single block of memory.</p> <p>The <strong>metadata</strong> includes important information about the data buffer. We can access the metadata like this:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="n">x</span><span class="p">.</span><span class="n">__array_interface__</span>
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="sh">'</span><span class="s">data</span><span class="sh">'</span><span class="p">:</span> <span class="p">(</span><span class="mi">105553130143936</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span>
 <span class="sh">'</span><span class="s">descr</span><span class="sh">'</span><span class="p">:</span> <span class="p">[(</span><span class="sh">''</span><span class="p">,</span> <span class="sh">'</span><span class="s">&lt;i8</span><span class="sh">'</span><span class="p">)],</span>
 <span class="sh">'</span><span class="s">shape</span><span class="sh">'</span><span class="p">:</span> <span class="p">(</span><span class="mi">6</span><span class="p">,),</span>
 <span class="sh">'</span><span class="s">strides</span><span class="sh">'</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span>
 <span class="sh">'</span><span class="s">typestr</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">&lt;i8</span><span class="sh">'</span><span class="p">,</span>
 <span class="sh">'</span><span class="s">version</span><span class="sh">'</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
</code></pre></div></div> <p>For instance, each <code class="language-plaintext highlighter-rouge">ndarray</code> has a data type, or <code class="language-plaintext highlighter-rouge">dtype</code>, which specifies what type of elements it contains (e.g., <code class="language-plaintext highlighter-rouge">float64</code>, <code class="language-plaintext highlighter-rouge">float16</code> or <code class="language-plaintext highlighter-rouge">int32</code>). If we need further memory savings, we can consider reducing the numerical precision:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="sh">"</span><span class="s">float16</span><span class="sh">"</span><span class="p">).</span><span class="n">nbytes</span> <span class="c1"># 6
</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="sh">"</span><span class="s">float64</span><span class="sh">"</span><span class="p">).</span><span class="n">nbytes</span> <span class="c1"># 24
</span></code></pre></div></div> <h2 id="vectorization">Vectorization</h2> <p>Vectorization refers to computing multiple computations at once. As an example:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># non-vectorized
</span><span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>

<span class="c1"># we sequentially iterate the
# pairs and compute the sum
</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)]</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[5, 7, 9]
</code></pre></div></div> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># vectorized
</span><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
<span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>

<span class="c1"># all 3 sums happen at once
</span><span class="n">xs</span> <span class="o">+</span> <span class="n">ys</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>array([5, 7, 9])
</code></pre></div></div> <p>Importantly, a vectorized operation is vastly faster than its explicit <code class="language-plaintext highlighter-rouge">for</code> loop counterpart. To understand why, we need to take a step back, and <a href="../hardware">understand how the RAM and the CPU interact</a>. CPU and RAM are the two sides of this story.</p> <h3 id="on-the-memory-side">On the memory side</h3> <p>First, Python’s native data structures are highly <strong>fragmented</strong>. This severely hampers the prefetcher, and <a href="../hardware#cache-and-prefetching">cache misses</a> are common. In other words, the list is an object with an attribute containing a reference to an array which in turn stores references to float objects. The object, the array and the floats are scattered across memory. (Potentially, this could be solved by <a href="https://docs.python.org/3/library/array.html" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">arrays</code></a>. But they seem to have their own downsides.) Keeping data together, as <code class="language-plaintext highlighter-rouge">ndarrays</code> do, leads to less cache misses. (Additional gains are possible by reducing the number of <a href="../hardware">cache lines</a> an array spans, e.g., using aligning their beginning to the memory grid. So far I have find some indications, but not strong sources supporting that NumPy attempts this too.)</p> <p>Second, Python is <strong>dynamically</strong> typed. This means that every operation between two numbers becomes a complex interaction between two heavy data structures. Internally, Python needs to find out the types of the objects, recover their values, run the computation, and store the result in a new object. Statically typed languages avoid much of this overhead.</p> <h3 id="on-the-cpu-side">On the CPU side</h3> <p>Vectorization has another meaning in hardware. Specifically, it refers to SIMD, the ability of the CPU to <a href="../hardware#registers-and-simd">handle multiple numbers in a single instruction</a>. CPython does not leverage SIMD, or gives us access to them. However, many NumPy functions are implemented in low-level languages to take advantage of this instruction set. This leads to even faster code. However, we won’t take advantage of this optimization when using Python-implemented vector operations, for instance custom transformations of our data.</p> <h3 id="further-efficiency-gains">Further efficiency gains</h3> <h4 id="row-vs-column-operations">Row vs. column operations</h4> <p>By default, <code class="language-plaintext highlighter-rouge">ndarrays</code> store matrices in a row-major order, that is, as a concatenation of the rows of the matrix. In other words, the elements from the same row live close (sharing cache lines), but the ones in the same column might live very far apart. Since retrieving one element will copy to the CPU cache the whole matrix row, row operations are fast. In contrast, column operations are slow, since they require copying as many cache lines as rows. Let’s see one example:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="n">time</span>

<span class="c1"># create a large matrix
</span><span class="n">n_rows</span> <span class="o">=</span> <span class="mi">100_000</span>
<span class="n">n_cols</span> <span class="o">=</span> <span class="mi">100_000</span>

<span class="c1"># the default order is "C",
# which confusingly refers to row-major
</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">((</span><span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">),</span> <span class="n">order</span> <span class="o">=</span> <span class="sh">"</span><span class="s">C</span><span class="sh">"</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="sh">"</span><span class="s">int8</span><span class="sh">"</span><span class="p">)</span>

<span class="c1"># time row operation
</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># sum the columns row-wise
</span><span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="n">row_time</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Time taken for the row operation:</span><span class="sh">"</span><span class="p">,</span> <span class="n">row_time</span><span class="p">)</span>

<span class="c1"># time column operation
</span><span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># sum the rows col-wise
</span><span class="n">end_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="nf">time</span><span class="p">()</span>
<span class="n">col_time</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Time taken for the column operation:</span><span class="sh">"</span><span class="p">,</span> <span class="n">col_time</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Time taken for the row operation: 8.663719177246094
Time taken for the column operation: 9.641089916229248
</code></pre></div></div> <p>(Note that <code class="language-plaintext highlighter-rouge">ndarray.sum()</code> calls an efficient, low-level function. The gap is much larger for most user-defined functions.)</p> <p>Consistenly, shifting to column-major order (<code class="language-plaintext highlighter-rouge">order = "F"</code>) produces the opposite result.Carefully considering the operations we will be carrying out can have a major impact.</p> <h1 id="views-copies-and-in-place-operations">Views, copies and in-place operations</h1> <p>NumPy introduced an important but tricky concept: data <em>views</em>. A views is just a new way to access the data buffer of an existing <code class="language-plaintext highlighter-rouge">ndarray</code>, with different metadata. Some operations produce views, like basic indexing (i.e., using single indexes and slices):</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>

<span class="c1"># x and y point to the same data buffer
</span><span class="k">assert</span> <span class="n">x</span><span class="p">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="sh">'</span><span class="s">data</span><span class="sh">'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="sh">'</span><span class="s">data</span><span class="sh">'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div> <p>We can check if an ndarray is a view using the base attribute:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span> <span class="n">x</span><span class="p">.</span><span class="n">base</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="k">assert</span> <span class="n">y</span><span class="p">.</span><span class="n">base</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
<span class="k">assert</span> <span class="n">y</span><span class="p">.</span><span class="n">base</span> <span class="ow">is</span> <span class="n">x</span>
</code></pre></div></div> <p>Other operations return a copy of the data:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="c1"># advanced indexing
# (e.g., integer or boolean arrays)
</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">]</span>

<span class="k">assert</span> <span class="n">y</span><span class="p">.</span><span class="n">base</span> <span class="ow">is</span> <span class="bp">None</span>
<span class="k">assert</span> <span class="n">z</span><span class="p">.</span><span class="n">base</span> <span class="ow">is</span> <span class="bp">None</span>

<span class="c1"># arithmetic operations
</span><span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">assert</span> <span class="n">y</span><span class="p">.</span><span class="n">base</span> <span class="ow">is</span> <span class="bp">None</span>
</code></pre></div></div> <p>Other functions, like <code class="language-plaintext highlighter-rouge">numpy.reshape</code> or <code class="language-plaintext highlighter-rouge">numpy.ravel</code>, will produce a view whenever possible and a copy otherwise.</p> <p>Lastly, note that some operations happen in-place:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="n">pointer_1</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="sh">'</span><span class="s">data</span><span class="sh">'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">pointer_2</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="sh">'</span><span class="s">data</span><span class="sh">'</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="k">assert</span> <span class="n">pointer_1</span> <span class="o">==</span> <span class="n">pointer_2</span>
<span class="k">assert</span> <span class="n">x</span><span class="p">.</span><span class="n">base</span> <span class="ow">is</span> <span class="bp">None</span>
</code></pre></div></div> <p>Let’s see some specific cases.</p> <h2 id="casting">Casting</h2> <p>Casting is the conversion of data from one type into another. The simplest form of casting is simply changing the type of an <code class="language-plaintext highlighter-rouge">ndarray</code>:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="sh">"</span><span class="s">int8</span><span class="sh">"</span><span class="p">)</span> <span class="c1"># x.dtype is int64
</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="nf">astype</span><span class="p">(</span><span class="sh">"</span><span class="s">float16</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>In general, casting triggers a copy:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span> <span class="n">y</span><span class="p">.</span><span class="n">base</span> <span class="ow">is</span> <span class="bp">None</span>
</code></pre></div></div> <p>Casting commonly occurs when performing arithmetic operations between different types. In those cases, NumPy picks the largest type that can safely represent both operants without losing precision. For instance, <code class="language-plaintext highlighter-rouge">x + y</code> involves <code class="language-plaintext highlighter-rouge">int8</code> and <code class="language-plaintext highlighter-rouge">float16</code>. Since the latter can represent the former, the type of the sum will be <code class="language-plaintext highlighter-rouge">float16</code>.</p> <h2 id="explicit-viewing">Explicit viewing</h2> <p>We can explicitly trigger a reinterpretation of the data buffer under another type using <code class="language-plaintext highlighter-rouge">ndarray.view()</code>. Note that produces a view, not a re-casting of the original <code class="language-plaintext highlighter-rouge">ndarray</code>. Let’s see an example:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="sh">"</span><span class="s">uint8</span><span class="sh">"</span><span class="p">)</span>
<span class="n">binary_repr</span> <span class="o">=</span> <span class="sh">''</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="nf">format</span><span class="p">(</span><span class="n">byte</span><span class="p">,</span> <span class="sh">'</span><span class="s">08b</span><span class="sh">'</span><span class="p">)</span> <span class="k">for</span> <span class="n">byte</span> <span class="ow">in</span> <span class="n">x</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="nf">tobytes</span><span class="p">())</span>

<span class="nf">print</span><span class="p">(</span><span class="n">binary_repr</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000000100000010
</code></pre></div></div> <p>This is what our array looks like in memory. We can see the binary encoding as an <code class="language-plaintext highlighter-rouge">np.unit8</code> of 1 (<code class="language-plaintext highlighter-rouge">00000001</code>) and of 2 (<code class="language-plaintext highlighter-rouge">00000010</code>). <code class="language-plaintext highlighter-rouge">ndarray.view()</code> can reinterpret this sting of 16 bits as an <code class="language-plaintext highlighter-rouge">np.int16</code>:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">assert</span> <span class="n">x</span><span class="p">.</span><span class="nf">view</span><span class="p">(</span><span class="sh">"</span><span class="s">int16</span><span class="sh">"</span><span class="p">).</span><span class="nf">byteswap</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nf">int</span><span class="p">(</span><span class="n">binary_repr</span><span class="p">,</span> <span class="n">base</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># 258
</span></code></pre></div></div> <p>Ignore the <code class="language-plaintext highlighter-rouge">byteswap()</code> call. <a href="https://numpy.org/devdocs/user/byteswapping.html#changing-byte-ordering" rel="external nofollow noopener" target="_blank">It relates to how NumPy parses a sequence of bits.</a></p> <h1 id="broadcasting">Broadcasting</h1> <h1 id="further-reading">Further reading</h1> <ul> <li>M. Gorelick &amp; I. Ozsvald, High Performance Python: Practical Performant Programming for Humans. Chapter 5. Matrix and Vector Computation.</li> <li>A series of <a href="https://pythonspeed.com/" rel="external nofollow noopener" target="_blank">Python⇒Speed</a> articles: <ul> <li><a href="https://pythonspeed.com/articles/vectorization-python-alternatives/" rel="external nofollow noopener" target="_blank">The limits of Python vectorization as a performance technique</a></li> <li><a href="https://pythonspeed.com/articles/vectorization-python/" rel="external nofollow noopener" target="_blank">How vectorization speeds up your Python code</a></li> <li><a href="https://pythonspeed.com/articles/python-integers-memory/" rel="external nofollow noopener" target="_blank">Massive memory overhead: Numbers in Python and how NumPy helps</a></li> </ul> </li> <li><a href="https://viralinstruction.com/posts/hardware/" rel="external nofollow noopener" target="_blank">What scientists must know about hardware to write fast code</a></li> <li><a href="https://scipy-lectures.org/advanced/advanced_numpy/" rel="external nofollow noopener" target="_blank">Scipy lecture notes: Advanced NumPy</a></li> </ul> </div> </article> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'hclimente/hclimente.github.io',
        'data-repo-id': '',
        'data-category': 'Comments',
        'data-category-id': '',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-lang': 'en',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> </div> </div> <footer class="sticky-bottom mt-5" role="contentinfo"> <div class="container"> © Copyright 2025 Héctor Climente-González. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>