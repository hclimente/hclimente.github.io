---
layout: post
title: An intro to uv
date: 2025-03-15 11:59:00-0000
description: Python package & project management
tags: python coding
giscus_comments: true
related_posts: false
toc:
  sidebar: left
---

Python veterans will be familiar with `pip`, `poetry`, `pyenv` and a few other packages that handle packages and environments. `uv`'s goal is replacing all of them: for a new project, `uv` installs a given version of Python, all the required dependencies, handles [TO COMPLETE] In this post, I give an overview of its features.

# First steps

When we start a new project, we simply need to run

```python
uv init hello-world
```

This creates a path `hello-world` in the current directory containing a set of files. By default, those are: a `.python-version`, a `pyproject.toml`, a `README.md` and a `main.py`. Furthermore, it will start out a git repository, with a sensible `.gitignore`. Let's see those files in more detail.

`pyproject.toml` contains the project's metadata:

```toml
[project]
name = "hello-world"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.10"
dependencies = []
```

`.python-version` contains the project's Python version:

```
3.10
```

# Replacing venv

The default `main.py` is a very short, example script. We can run it using our default Python, as we are used to: `python main.py`. But we can also run it using `uv`: `uv run main.py`. This will create the project environment if it does not exist, or ensuring it is up to date if it does, and run `main.py` using its Python.

> Python has a native support for different environments, using [`venv`](https://docs.python.org/3/library/venv.html). Each virtual environment contains its own installation of Python (as specified in `.python-version`) and installed packages. They all live in the `.venv` directory. When Python runs from within an environment, it uses the packages installed in that environment, and only them. Typically, we would activate this environment from `zsh` by running `source .venv/bin/activate`, which would load `.venv/bin/` into our `PATH`, containing a `python`.

# Replacing pip

`uv run` also created a `uv.lock` file which contains the specific package resolutions. Let's get a better understanding of how `uv` handles environments by installing the [`pandas`](https://pypi.org/project/pandas/) package. Typically we would run `pip install pandas`; but in `uv` we would use `uv add pandas` instead. This installs the the most recent version of the package that is compatible with our environment (2.2.3). This is reflected in `pyproject.toml`:

```toml
...
dependencies = [
    "pandas>=2.2.3",
]
```

This is a general specification of environment that our project depends on. `uv.lock` is also updated, with considerably more thorough specification. (In my machine it consisted of 167 lines, and I will not reproduce it here.) `uv.lock` should be under git control. Its there to provide the exact recipe to replicate your environment, ensuring reproducibility. By default, `uv run` will make sure that everything, environment, `uv.lock` and `pyproject.toml`, are in sync. This can also be forced manually by running `uv sync`.

`uv` comes with other common operations to handle packages:

- `uv remove` uninstalls `pandas` and removes it from the specifications
- `uv lock --upgragde package pandas` tries to upgrade `pandas`' version

## Adding development dependencies

As a data scientist, Jupyter notebooks are my bread and butter. I like to keep my Jupyter notebooks as plain Python scripts using [Jupytext](https://jupytext.readthedocs.io/en/latest). In order to run a Jupyter notebook on our `uv` environment, we need to install the [IPython kernel](https://pypi.org/project/ipykernel/). However, the kernel is not a dependency of our code, but a tool that we need for development. The same would apply to tools like `pytest`. `uv` allows to add development dependencies with `uv add --dev ipykernel`, which will add the following to `pyproject.toml`:

```toml
[dependency-groups]
dev = [
    "ipykernel>=6.29.5",
]
```

I used this to allow Visual Studio Code to find this Python environment and run Jupyter notebooks on it.

# Further reading

- [A year of uv: pros, cons, and should you migrate](https://www.bitecode.dev/p/a-year-of-uv-pros-cons-and-should)
