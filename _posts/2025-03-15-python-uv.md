---
layout: post
title: An intro to uv
date: 2025-03-15 11:59:00-0000
description: Python environments, project management & more
tags: python coding
giscus_comments: true
related_posts: false
toc:
  sidebar: left
---

Python veterans will be familiar with `pip`, `poetry`, `pyenv` and a few other tools for managing packages and environments. [`uv`](https://github.com/astral-sh/uv)'s goal is to replace them all while being blazingly fast. Let's see how it works.

# First steps

When we start a new project, we simply need to run `uv init`.

```python
uv init hello-world
```

This creates a directory `hello-world` in the current directory containing a few files; we'll see them in more detail later. Furthermore, it will start a git repository, with a sensible `.gitignore`.

By default, `init` creates an _application_ project. This is appropriate for scripts, like simple tools. This is why the command above created a `main.py` file, meant to be the entry point of our application. Alternatively, we could create a _library_ project with `uv init --package hello-world-pkg`. This would create a new directory `hello-world-pkg` and populate it with a standard structure and configuration suitable for a Python library.

## Project configuration

`uv init` creates a [`pyproject.toml`](https://packaging.python.org/en/latest/guides/writing-pyproject-toml/) to store the project's metadata. This is a standard file used by other tools like [`poetry`](https://python-poetry.org/) and [`pip`](https://pip.pypa.io). For instance `pip install .` would install all the packages listed under the `dependencies` field. The `pyproject.toml` file created by `uv` looks like this:

```toml
[project]
name = "hello-world"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.10"
dependencies = []
```

`uv` commands will update this file when needed (e.g., when [adding a dependency](#uninstalling-packages)).

# Handling environments

Multiple Python projects can be run on the same machine, and they can depend on different versions of the same package. This is solved by creating _virtual environments_. These are self-contained directories containing a Python interpreter and an independent set of Python packages. There are multiple solutions to create and manage virtual environments, like [`venv`](https://docs.python.org/3/library/venv.html), [`conda`](https://anaconda.org/anaconda/conda) or [`poetry`](https://python-poetry.org/).

`uv` leverages Python's native support for different environments: `venv`. The virtual environment contains its own installation of Python, whose version is specified in `.python-version`. `uv init` created this file:

```
3.10
```

The virtual environment packages live in the `.venv` directory. When Python runs from within an environment, it uses the packages installed in that environment, and only those packages. Typically, we would activate this environment from `zsh` with `source .venv/bin/activate`, which would append `.venv/bin/` into our `PATH`, loading the `python` located there into our environment. However `uv` does not require explicitly activating the environment. Instead, it uses the `uv run` command to run any Python script or command using the environment's Python. For instance, `uv init` created a short, example script `main.py`:

```python
def main():
    print("Hello from hello-world!")

if __name__ == "__main__":
    main()
```

As stated, we can run it using our default Python, as we are used to (`python main.py`), maybe after loading the relevant environment. But we can also run it using `uv run main.py`. This offers two conveniences. First, we do not need to load and unload environments, reducing effort and the probability of error. Second, if the project environment does not exist, it will create it. If it exists, `uv` will ensure it is up to date. Then, it runs `main.py` using its Python. Similarly, we can run an interactive Python session via `uv run python`.

# (Un)installing packages

Upon its first run, `uv run main.py` created a virtual environment. To do this, it examined the (empty) `dependencies` list in `pyproject.toml` and resolved an (empty) set of packages. `uv` records this exact state in the `uv.lock` file, detailing the specific package resolutions. Let's get a better understanding of how `uv` handles environments by installing the [`pandas`](https://pypi.org/project/pandas/) package. Typically we would run `pip install pandas`; but in `uv` we would use `uv add pandas` instead. This installs the most recent version of the package that is compatible with our environment (2.2.3). In this process, `pyproject.toml` gets updated to:

```toml
...
dependencies = [
    "pandas>=2.2.3",
]
```

This adds a general specification of environment that our project depends on. But `uv.lock` is also updated with considerably more thorough specification. Specifically, it expanded to 167 lines describing all the specific packages, their versions and the metadata that were installed in the environment. This is a small excerpt of the file:

```
[[package]]
name = "appnope"
version = "0.1.4"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/35/5d/752690df9ef5b76e169e68d6a129fa6d08a7100ca7f754c89495db3c6019/appnope-0.1.4.tar.gz", hash = "sha256:1de3860566df9caf38f01f86f65e0e13e379af54f9e4bee1e66b48f2efffd1ee", size = 4170 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/81/29/5ecc3a15d5a33e31b26c11426c45c501e439cb865d0bff96315d86443b78/appnope-0.1.4-py2.py3-none-any.whl", hash = "sha256:502575ee11cd7a28c0205f379b525beefebab9d161b7c964670864014ed7213c", size = 4321 },
]

[[package]]
name = "asttokens"
version = "3.0.0"
source = { registry = "https://pypi.org/simple" }
sdist = { url = "https://files.pythonhosted.org/packages/4a/e7/82da0a03e7ba5141f05cce0d302e6eed121ae055e0456ca228bf693984bc/asttokens-3.0.0.tar.gz", hash = "sha256:0dcd8baa8d62b0c1d118b399b2ddba3c4aff271d0d7a9e0d4c1681c79035bbc7", size = 61978 }
wheels = [
    { url = "https://files.pythonhosted.org/packages/25/8a/c46dcc25341b5bce5472c718902eb3d38600a903b14fa6aeecef3f21a46f/asttokens-3.0.0-py3-none-any.whl", hash = "sha256:e3078351a059199dd5138cb1c706e6430c05eff2ff136af5eb4790f9d28932e2", size = 26918 },
]
```

`uv.lock` should be under git control, providing the exact recipe to replicate an environment, hence ensuring reproducibility. By default, `uv run` will make sure that environment, `uv.lock` and `pyproject.toml` are consistent with each other. This can also be forced manually with `uv sync`.

Other common operations to handle packages are `uv remove <package_name>`, to uninstall `<package_name>`; and `uv lock --upgragde package <package_name>` to upgrade `<package_name>`'s version if possible.

## Adding development dependencies

As a data scientist, Jupyter notebooks are my bread and butter. In order to run Jupyter notebooks on our `uv` environment, we need to install the [IPython kernel `ipykernel`](https://pypi.org/project/ipykernel/). However, `ipykernel` is qualitatively different from other packages: it is not a dependency of our code, but a tool needed for development. Once my code is ready, I will distribute it as a standalone Python script that has no dependencies on `ipykernel`. The same principle applies to tools like `pytest`, used to test your code, but which the end-user shouldn't require unless they intend to contribute to the project.

`uv` allows to add development dependencies with `uv add --dev ipykernel`, which will add the following to `pyproject.toml`:

```toml
[dependency-groups]
dev = [
    "ipykernel>=6.29.5",
]
```

This allows Visual Studio Code to find this virtual environment and run Jupyter notebooks on it.

## Adding development dependencies

As a data scientist, Jupyter notebooks are my bread and butter. I like to keep my Jupyter notebooks as plain Python scripts using [Jupytext](https://jupytext.readthedocs.io/en/latest). In order to run a Jupyter notebook on our `uv` environment, we need to install the [IPython kernel](https://pypi.org/project/ipykernel/). However, the kernel is not a dependency of our code, but a tool that we need for development. The same would apply to tools like `pytest`. `uv` allows to add development dependencies with `uv add --dev ipykernel`, which will add the following to `pyproject.toml`:

```toml
[dependency-groups]
dev = [
    "ipykernel>=6.29.5",
]
```

I used this to allow Visual Studio Code to find this Python environment and run Jupyter notebooks on it.

# Further reading

- [A year of uv: pros, cons, and should you migrate](https://www.bitecode.dev/p/a-year-of-uv-pros-cons-and-should)
